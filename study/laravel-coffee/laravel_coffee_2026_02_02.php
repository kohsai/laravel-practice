<?php

/**
 * ☕ Laravelコーヒー 2026/02/18
 *
 * フェーズ：1（ヒントあり）
 * 出題範囲：Day1〜Day5（Eloquent基礎・リレーション含む）
 * 前回正解率：8/8（100%）
 */

// ☕ Laravelコーヒー 第1問（テーマ：ルーティング）

// 🎯 【穴埋め問題】
// 次のコードは「GETリクエストで `/profile` にアクセスしたとき、
// `UserController` の `show` メソッドを呼び出す」ルートです。
// （　）に入る正しいコードを選んでください。

// Route::get('/profile', [（　）::class, 'show']);

// 🔤 【選択肢】
// A. User
// B. UserController
// C. UserModel
// D. ProfileRoute

// 💡 【ヒント】
// コントローラーのファイル名を思い出してみてください。
// app/Http/Controllers/ の中に入っているファイルです。

// ✅ 【回答欄】
// 回答：___B____

// 使うのがLaravelのControllerを
// 継承しているUserControllerなので、
// Bとなります。
// 「app/Http/Controllers/ の中に入っているファイルです。」の意味を教えてください。


// 🧠 【採点と解説】

// ✅ 正解！答えは B. UserController
//
// なぜBか：
// ルートはどのコントローラーに処理を頼むか指定する場所です。UserController という「係の人」を名指しで呼んでいます。User はモデル（データの型）なので別物です。
// 「app/Http/Controllers/ の中に入っているファイル」の意味：
// Laravelのフォルダ構成はこうなっています。

// app/Http/Controllers/UserController.php ← コントローラーはここ
// app/Models/User.php ← モデルはここ

// 「Controllers フォルダの中のファイル名がそのままクラス名になる」というルールがあります。UserController.php というファイルがあるから、クラス名も UserController になる、という意味でヒントに書きました。
// つまり 「ファイルの場所を見れば、何という名前のクラスを使えばいいか分かる」 という案内でした。


// ☕ Laravelコーヒー 第2問（テーマ：Eloquent基本操作）

// 🎯 【穴埋め問題】
// 次のコードは「年齢が20以上のユーザーを全員取得する」処理です。
// （　）に入る正しいコードを選んでください。

// $users = User::where('age', '（　）', 20)->get();

// 🔤 【選択肢】
// A. =>
// B. >=
// C. ->
// D. ==

// 💡 【ヒント】
// 「以上」は「同じか、それより大きい」という意味です。
// 算数で使う不等号を思い出してみてください。

// ✅ 【回答欄】
// 回答：___B____
// 「同じか、それより大きい」のは「＞＝」なので、Bです。


// 🧠 【採点と解説】

// ✅ 正解！答えは B. >=
//
// >= は「以上（同じか、それより大きい）」を意味する比較演算子です。
// where() の第2引数には以下のような演算子が使えます。
//
// '='  → 等しい
// '!=' → 等しくない
// '>'  → より大きい
// '>=' → 以上
// '<'  → より小さい
// '<=' → 以下
// 'like' → 部分一致（'%テスト%' のように使う）
//
// 実務での使用例：
// 成人ユーザーのみ取得 → where('age', '>=', 18)
// 一定金額以上の注文を取得 → where('price', '>=', 1000)


// ☕ Laravelコーヒー 第3問（テーマ：Eloquentリレーション）

// 🎯 【選択問題】
// User モデルが複数の Post を持つとき、
// User モデルに定義するリレーションメソッドとして正しいものはどれですか？

// 🔘 【選択肢】
// A. return $this->belongsTo(Post::class);
// B. return $this->hasOne(Post::class);
// C. return $this->hasMany(Post::class);
// D. return $this->belongsToMany(Post::class);

// 💡 【ヒント】
// 「1人のユーザーが複数の投稿を持つ」関係です。
// 「複数」を表す英単語を選択肢の中から探してみてください。

// ✅ 【回答欄】
// 回答：___C____
// 「複数の○○を持つ」なので、「has（持つ）many（複数）」です。


// 🧠 【採点と解説】
// ✅ 正解！答えは C. hasMany
//
// KOHさんの説明が完璧です。
// has（持つ）+ Many（複数）= 「複数持っている」関係。
//
// 4つのリレーションの使い分け：
// hasOne()        → 1対1（ユーザーは1つのプロフィールを持つ）
// hasMany()       → 1対多（ユーザーは複数の投稿を持つ）← 今回
// belongsTo()     → 多対1（投稿は1人のユーザーに属する）
// belongsToMany() → 多対多（ユーザーは複数のタグを持ち、タグも複数のユーザーに使われる）
//
// 覚え方：
// 「持つ側」 → has〇〇 を使う（User が Post を持つ → User モデルに hasMany）
// 「属する側」→ belongsTo を使う（Post が User に属する → Post モデルに belongsTo）


// ☕ Laravelコーヒー 第4問（テーマ：Blade）

// 🎯 【穴埋め問題】
// 次のコードは「$users が空でないとき一覧を表示し、
// 空のときは「ユーザーがいません」と表示する」Bladeテンプレートです。
// （　）に入る正しいコードを選んでください。

// @foreach($users as $user)
//     <p>{{ $user->name }}</p>
// @endforeach
// （　）
//     <p>ユーザーがいません</p>
// @endforelse

// 🔤 【選択肢】
// A. @else
// B. @empty
// C. @nothing
// D. @blank

// 💡 【ヒント】
// @foreach ではなく、「空のとき」も扱える特別なディレクティブと組み合わせて使います。
// @endforelse が閉じタグになっていることがヒントです。

// ✅ 【回答欄】
// 回答：___A___

// @endforelseが閉じタグになっているので、「else」、回答はAだと思います。
// 「@foreach ではなく、「空のとき」も扱える特別なディレクティブと組み合わせ」の意味を、分かりやすく教えてください。

// 🧠 【採点と解説】
// ❌ 不正解。答えは B. @empty
//
// 【なぜ @else ではないのか】
// @endforelse という閉じタグが「ヒント」と書きましたが、
// 少し難しかったですね。説明します。
//
// 通常の @foreach はこう使います：
//
// @foreach($users as $user)
//     <p>{{ $user->name }}</p>
// @endforeach
//
// これは「空のとき」を扱えません。
// データが0件でも何も表示されないだけです。
//
// 「空のとき」も扱いたい場合は @forelse を使います：
//
// @forelse($users as $user)
//     <p>{{ $user->name }}</p>
// @empty                      ← データが0件のときここに入る
//     <p>ユーザーがいません</p>
// @endforelse
//
// つまり：
// @foreach → ただループするだけ（空のときの処理なし）
// @forelse → ループ ＋ 空のときの処理ができる「特別なディレクティブ」
//
// @empty は「空のとき」を意味する @forelse 専用のキーワードです。
// @else とは別物なので注意してください。
//
// 覚え方：
// @forelse ＋ @empty ＋ @endforelse はセットで覚える！

// 【返信】
// 以下の解説、
// 「つまり：
// @foreach → ただループするだけ（空のときの処理なし）
// @forelse → ループ ＋ 空のときの処理ができる「特別なディレクティブ」
//
// @empty は「空のとき」を意味する @forelse 専用のキーワードです。
// @else とは別物なので注意してください。
// 」
// ですが、
// @foreachや@forelseの違いや使い方について、教材のどの部分で行ないましたか？
// そもそも行なってますか？確認してください。


// ⚠️ 【第4問 出題ミスのため無効】
// @forelse / @empty はDay1〜Day5の教材で未登場のため、
// 出題範囲外でした。この問題は無効とします。
// 正解率のカウントからも除外します。


// ☕ Laravelコーヒー 第5問（テーマ：Eloquentリレーション）

// 🎯 【選択問題】
// 以下のコードを実行すると、どのような結果になりますか？
// （Userは複数のExpenseを持つ hasMany リレーションが定義済みです）

// $user = User::find(1);
// $expenses = $user->expenses;

// 🔘 【選択肢】
// A. ID=1のユーザー情報だけが表示される
// B. ID=1のユーザーが持つ、すべての支出データが取得される
// C. すべてのユーザーの支出データが取得される
// D. エラーが発生する

// 💡 【ヒント】
// 1行目でユーザーを1人取得しています。
// 2行目の $user->expenses は、そのユーザーに紐づく何かを取得しています。
// リレーションの「has（持つ）Many（複数）」を思い出してください。

// ✅ 【回答欄】
// 回答：___B____

// 1行目で＄userがfind（1）により、ID＝１のユーザーを取得しているので、
// ＄expensesは＄user（ID＝１）のexpenses（特に指定がないので「支出すべて」）を
// 取得する。だからBだと思います。

// 🧠 【採点と解説】
// ✅ 正解！答えは B
//
// KOHさんの説明が完璧です。
// 「find(1) で1人に絞る → その人のexpensesを全部取る」
// という流れを正確に読み取れています。
//
// 【コードの分解】
// $user = User::find(1);
//  → ID=1のユーザーを1人取得して $user に入れる
//
// $expenses = $user->expenses;
//  → $user（ID=1の人）に紐づくExpenseを全件取得
//  → hasMany で定義しているので「複数」返ってくる
//  → 結果は Collection（コレクション）で返る
//
// 【-> expenses のしくみ】
// $user->expenses と書くだけで、Laravelが自動的に
// 「expenses テーブルから user_id = 1 のデータを全件取得」
// という SQL を実行してくれます。
//
// 実際に実行される SQL のイメージ：
// SELECT * FROM expenses WHERE user_id = 1
//
// 【hasOne との違い】
// hasOne  → 1件だけ返る（単数）
// hasMany → 全件返る（Collection）← 今回


// ☕ Laravelコーヒー 第6問（テーマ：Eloquent基本操作）

// 🎯 【穴埋め問題】
// 次のコードは「メールアドレスが test@example.com の
// ユーザーを1人だけ取得する」処理です。
// （　）に入る正しいコードを選んでください。

// $user = User::where('email', 'test@example.com')->（　）();

// 🔤 【選択肢】
// A. all
// B. get
// C. first
// D. find

// 💡 【ヒント】
// get() は「条件に合う全員」を取得します。
// 今回は「1人だけ」取得したいです。
// 「最初の1件」を意味する英単語を選んでください。

// ✅ 【回答欄】
// 回答：___C____

//ヒントの 「「最初の1件」を意味する英単語を選んでください。」がほぼ回答ですが、
// でも今回は今のヒントが無ければ、すぐには分かりませんでした。
// でも、ユーザーを一人だけ取得という条件だったので、
// allやgetではないな、と分かりました。
// findも見たことないな・・・くらいで消去して、結果として「C」のfirstを選びました。

// 🧠 【採点と解説】
// ✅ 正解！答えは C. first()
//
// 【消去法について】
// 「allとgetではない→findも違う→firstだ」という消去法は
// 正しい思考プロセスです。知識が定着していく過程では自然な流れです。
//
// 【4つの違いを整理】
// all()   → 条件なしで全件取得。where()と組み合わせて使わない
//           例：User::all();
//
// get()   → 条件に合う全件取得。where()の後に使う
//           例：User::where('age', '>=', 20)->get();
//
// first() → 条件に合う最初の1件だけ取得。where()の後に使う ← 今回
//           例：User::where('email', 'test@example.com')->first();
//
// find()  → IDで1件取得。where()は不要
//           例：User::find(1);
//
// 【覚え方】
// 「1人だけほしい」場面は2パターン：
// IDがわかっている → find()
// ID以外の条件    → where()->first()
//
// 【実務での使用例】
// ログイン処理でメールアドレスからユーザーを探す場面で
// where()->first() はよく使います。


