<?php
/**
 * 📘 Day5 教材（Step5-04：Expenseモデルとマイグレーション作成）【統合版 パート1】
 * 
 * この教材では「自分でモデルとテーブルを作る方法」を学びます
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📚 【統合版について】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * このファイルは統合版のパート1です（全2パート）
 * 
 * パート1：基本教材 + 質問1-6
 * パート2：質問7-11
 * 
 * 作成日：2026/01/31
 * 学習時間：約2時間
 * 質問数：11問
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 第1部：基本教材
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🧠 【今日学ぶこと】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * これまでは「User（ユーザー）」という、
 * 最初から用意されていたモデルとテーブルを使ってきました。
 * 
 * 今日は「Expense（エクスペンス）＝支出」という
 * 新しいモデルとテーブルを自分で作ります。
 * 
 * 【ModelとMigrationの関係】
 * 
 * たとえ話：家を建てる場合
 * - Migration（マイグレーション）= 設計図
 * - Model（モデル）= その家に住む人が使う「家の使い方マニュアル」
 * - Table（テーブル）= 実際に建てられた家
 * 
 * 手順：
 * 1. 設計図を描く（マイグレーション作成）
 * 2. マニュアルを用意する（モデル作成）
 * 3. 実際に家を建てる（マイグレーション実行）
 * 4. 家に入れるようになる（モデルでデータ操作）
 * 
 * 【今日作るもの】
 * 
 * Expense（エクスペンス）= 支出記録
 * - いつ
 * - いくら
 * - 何に
 * - 誰が
 * という情報を記録するテーブルとモデル
 * 
 * 【Laravel全体での位置づけ】
 * 
 * データベース操作の流れ：
 * 1. マイグレーション = テーブル設計図作成 ← 今日ここ
 * 2. マイグレーション実行 = 実際のテーブル作成 ← 今日ここ
 * 3. モデル = データ操作用のPHPクラス ← 今日ここ
 * 4. Eloquent = モデルを使った便利な操作 ← Step5-02, 5-03で学習済み
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【1. ModelとMigrationの同時生成】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Laravelには便利なコマンドがあります。
 * 1つのコマンドで「モデル」と「マイグレーション」を同時に作れます。
 * 
 * 【コマンドの構成】
 * 
 * php artisan make:model Expense -m
 * 
 * 分解して説明：
 * - php artisan = Laravelの作業道具箱
 * - make:model = モデルを作る命令
 * - Expense = 作りたいモデルの名前
 * - -m = マイグレーションも一緒に作ってね（オプション）
 * 
 * 【-m オプションの意味】
 * 
 * -m（マイナス エム）= migration（マイグレーション）の頭文字
 * 
 * このオプションを付けると：
 * ✅ モデルファイルが作られる
 * ✅ マイグレーションファイルも作られる
 * 
 * このオプションを付けないと：
 * ❌ モデルファイルだけが作られる
 * ❌ マイグレーションは別コマンドで作る必要がある
 * 
 * 【たとえ話】
 * 
 * -m オプション = 「家の設計図と使い方マニュアルをセットで作って」
 * -m なし = 「使い方マニュアルだけ作って（設計図は後で別に作る）」
 */

/**
 * 【実行してみよう】
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 重要：artisan コマンドはどこで実行する？
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * artisan コマンドは「Dockerコンテナの中」で実行します。
 * 
 * 理由：
 * - artisan ファイルは Laravelプロジェクト内にある
 * - PHPの実行環境はDockerコンテナの中にある
 * - ホストマシンで実行すると「artisan: command not found」エラー
 * 
 * 【実行場所の違い】
 * 
 * ❌ ホストマシン（あなたのPC）
 * kohsai@kohsaipc:~/venpro/laravel-practice$
 * → ここで php artisan を実行してもエラー
 * 
 * ✅ Dockerコンテナ内
 * root@xxxx:/var/www/html#
 * → ここで php artisan を実行する
 * 
 * 【ディレクトリの対応関係】
 * 
 * ホストマシン：~/venpro/laravel-practice/src/laravel/
 * ↕️ マウント（つながっている）
 * コンテナ内：/var/www/html/
 * 
 * この2つは同じ内容が見えています。
 */

/**
 * 【実行手順】
 */

// 1. ホストマシンのターミナルで以下を実行：
// docker exec -it laravel-practice-php-1 bash

// 2. コンテナに入ったら、自動的に /var/www/html にいる
//    （Dockerfileで WORKDIR として設定済み）

// 3. artisan ファイルがあることを確認（念のため）：
// ls artisan

// 4. モデルとマイグレーションを作成：
// php artisan make:model Expense -m

/**
 * → 以下の2つのファイルが作られます：
 * 
 * 1. app/Models/Expense.php（モデル）
 * 2. database/migrations/2026_XX_XX_XXXXXX_create_expenses_table.php（マイグレーション）
 * 
 * 【ファイル名の日時について】
 * 
 * マイグレーションファイル名：
 * 2026_01_31_123456_create_expenses_table.php
 * ^^^^^^^^^^^^^^^^
 * この部分 = 実行した日時（年月日時分秒）
 * 
 * なぜ日時が付くのか？
 * - 複数のマイグレーションを実行する順番を管理するため
 * - 古い順に実行される
 * - 例：usersテーブルを先に作ってから、expensesテーブルを作る
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【2. マイグレーションファイルの構造】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 作られたマイグレーションファイルを開いてみましょう。
 * 
 * database/migrations/2026_XX_XX_XXXXXX_create_expenses_table.php
 * 
 * 【ファイルの中身（初期状態）】
 * 
 * 2つのメソッド（命令）があります：
 * 
 * 1. up()（アップ）= 「テーブルを作る」命令
 * 2. down()（ダウン）= 「テーブルを削除する」命令
 * 
 * 【たとえ話】
 * 
 * up() = 家を建てる
 * down() = 家を壊す（元に戻す）
 * 
 * 普段使うのは up() だけですが、
 * 間違えた時に down() で元に戻せるようになっています。
 * 
 * 【up() メソッドの構造】
 * 
 * Schema::create('expenses', function (Blueprint $table) {
 *     $table->id();
 *     $table->timestamps();
 * });
 * 
 * 分解して説明：
 * 
 * Schema::create（スキーマ::クリエイト）= テーブルを作る命令
 * 'expenses' = テーブル名（expensesという名前のテーブル）
 * function (Blueprint $table) = テーブルの設計図を書く場所
 * $table->id() = ID番号の列を作る
 * $table->timestamps() = created_at, updated_at の列を作る
 * 
 * 【Blueprint（ブループリント）って何？】
 * 
 * Blueprint = 英語で「設計図」という意味
 * $table という変数に Blueprint が入っている
 * 
 * つまり：
 * $table = テーブルの設計図
 * $table->id() = 設計図にID番号の欄を追加
 * $table->timestamps() = 設計図に日時記録の欄を追加
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【3. カラム（列）の定義 - expensesテーブルの設計】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 初期状態では id と timestamps しかありません。
 * ここに、支出記録に必要な列を追加します。
 * 
 * 【expensesテーブルに必要な情報】
 * 
 * 支出記録には以下の情報が必要です：
 * 
 * 1. 誰の支出か？ → user_id（ユーザーID）
 * 2. 何に使ったか？ → category（カテゴリ）例：食費、交通費
 * 3. いくら？ → amount（金額）
 * 4. メモは？ → description（説明）※任意
 * 5. いつ？ → spent_at（支出日）
 * 
 * これを設計図に追加します。
 * 
 * 【データ型（データタイプ）の選び方】
 * 
 * データ型 = その列にどんな種類のデータを入れるかを決めるもの
 * 
 * よく使うデータ型：
 * 
 * - id（アイディー）= 自動で増える番号（1, 2, 3...）
 * - foreignId（フォーリンアイディー）= 他のテーブルとつなぐID番号
 * - string（ストリング）= 短い文字（255文字まで）
 * - text（テキスト）= 長い文字（何文字でもOK）
 * - integer（インテジャー）= 整数（1, 2, 3...）
 * - decimal（デシマル）= 小数点付きの数字（100.50 など）
 * - date（デイト）= 日付（2025-12-31 など）
 * - timestamp（タイムスタンプ）= 日付と時刻（2025-12-31 12:34:56）
 * 
 * 【たとえ話】
 * 
 * データ型 = 引き出しの種類
 * - string = 小さい引き出し（短いメモ用）
 * - text = 大きい引き出し（長い文章用）
 * - integer = 数字だけ入れる引き出し
 * - date = カレンダー専用の引き出し
 * 
 * 【実際のカラム定義】
 * 
 * マイグレーションファイルの up() メソッド内を
 * 以下のように編集してください：
 */

/**
 * 【編集内容】
 * 
 * database/migrations/2026_XX_XX_XXXXXX_create_expenses_table.php
 * の up() メソッドを以下のように編集：
 */

// public function up(): void
// {
//     Schema::create('expenses', function (Blueprint $table) {
//         $table->id();
//         $table->foreignId('user_id')->constrained()->onDelete('cascade');
//         $table->string('category');
//         $table->decimal('amount', 10, 2);
//         $table->text('description')->nullable();
//         $table->date('spent_at');
//         $table->timestamps();
//     });
// }

/**
 * 【1行ずつ詳しく解説】
 * 
 * $table->id();
 * → ID番号の列を作る
 * → 自動で 1, 2, 3... と増えていく
 * → 主キー（プライマリーキー）= この列で各行を区別する
 * 
 * $table->foreignId('user_id')->constrained()->onDelete('cascade');
 * → 外部キー（がいぶキー）の列を作る
 * → 分解して説明：
 *    foreignId('user_id') = user_idという名前の外部キー列
 *    ->constrained() = usersテーブルのidと関連付ける
 *    ->onDelete('cascade') = ユーザーが削除されたら、その人の支出も全部削除
 * 
 * 【外部キーって何？】
 * 
 * 外部キー = 他のテーブルとつなぐための列
 * 
 * たとえ話：
 * - usersテーブル = 住民票
 * - expensesテーブル = 支出記録ノート
 * - user_id = 「この支出は誰のものか」を示す住民番号
 * 
 * 例：
 * users テーブル：
 * id | name
 * 1  | 太郎
 * 2  | 花子
 * 
 * expenses テーブル：
 * id | user_id | amount
 * 1  | 1       | 500円  ← 太郎の支出
 * 2  | 1       | 300円  ← 太郎の支出
 * 3  | 2       | 800円  ← 花子の支出
 * 
 * $table->string('category');
 * → カテゴリ名を入れる列
 * → 短い文字（255文字まで）
 * → 例：「食費」「交通費」「娯楽費」
 * 
 * $table->decimal('amount', 10, 2);
 * → 金額を入れる列
 * → decimal（デシマル）= 小数点付きの数字
 * → (10, 2) の意味：
 *    10 = 全体で10桁まで
 *    2 = 小数点以下2桁まで
 * → 例：12345678.90 まで入る
 * 
 * 【なぜ integer じゃなくて decimal？】
 * 
 * integer（整数）だと：
 * - 100円、200円はOK
 * - 150.50円は入れられない
 * 
 * decimal（小数）だと：
 * - 100円、200円もOK
 * - 150.50円も入れられる
 * 
 * お金の計算では小数点が必要な場合があるので decimal を使います。
 * 
 * $table->text('description')->nullable();
 * → メモを入れる列
 * → text = 長い文章もOK
 * → ->nullable() = 空欄でもOK
 * 
 * 【nullable（ヌラブル）って何？】
 * 
 * nullable = null（ヌル＝空っぽ）を許可する
 * 
 * ->nullable() を付けると：
 * ✅ メモを書かなくてもOK
 * ✅ 空欄で保存できる
 * 
 * ->nullable() を付けないと：
 * ❌ 必ず何か入れないとエラーになる
 * 
 * メモは任意（書いても書かなくてもいい）なので nullable を付けます。
 * 
 * $table->date('spent_at');
 * → 支出日を入れる列
 * → date = 日付だけ（時刻は含まない）
 * → 例：2025-12-31
 * 
 * $table->timestamps();
 * → created_at（作成日時）と updated_at（更新日時）の列を作る
 * → 自動で現在の日時が入る
 */

/**
 * 【onDelete('cascade') の詳しい説明】
 * 
 * cascade（カスケード）= 連鎖・滝のように流れる
 * 
 * onDelete('cascade') = 削除が連鎖する
 * 
 * 例：
 * 太郎さん（user_id = 1）がいて、
 * 太郎さんの支出が100件ある場合
 * 
 * 太郎さんを削除すると：
 * ✅ cascade あり → 太郎さんの支出100件も全部自動で削除される
 * ❌ cascade なし → 太郎さんは削除できない（支出が残っているから）
 * 
 * 【なぜ cascade が必要？】
 * 
 * ユーザーを削除したのに、そのユーザーの支出記録だけが残っていたら
 * おかしいですよね？
 * 
 * 「誰の支出かわからない支出」が残ってしまうのを防ぐために
 * cascade を設定します。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【4. マイグレーション実行 - 実際のテーブルを作る】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * マイグレーションファイルの編集が終わったら、
 * 実際にデータベースにテーブルを作ります。
 * 
 * 【たとえ話】
 * 
 * これまで：設計図を描いた
 * これから：設計図を見ながら実際に家を建てる
 * 
 * 【実行コマンド】
 * 
 * 重要：Dockerコンテナの中で実行します
 */

// Dockerコンテナに入る（ホストマシンのターミナルで実行）：
// docker exec -it laravel-practice-php-1 bash

// コンテナ内で実行：
// php artisan migrate

/**
 * → 以下のようなメッセージが表示されます：
 * 
 * Migrating: 2026_01_31_123456_create_expenses_table
 * Migrated:  2026_01_31_123456_create_expenses_table (XX.XXms)
 * 
 * 【成功の確認方法】
 * 
 * 1. phpMyAdmin を開く
 * 2. laravel_practice データベースを選択
 * 3. 左側のテーブル一覧に「expenses」が追加されている
 * 4. expenses テーブルをクリック
 * 5. 構造タブで列（カラム）を確認
 * 
 * 確認すべき列：
 * - id
 * - user_id
 * - category
 * - amount
 * - description
 * - spent_at
 * - created_at
 * - updated_at
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【5. Expenseモデルの設定】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * マイグレーション実行後、モデルファイルも編集します。
 * 
 * app/Models/Expense.php を開いてください。
 * 
 * 【fillable って何？】
 * 
 * fillable（フィラブル）= fill（満たす）+ able（できる）
 * = 「データを入れてもいい列」のリスト
 * 
 * 【編集内容】
 * 
 * app/Models/Expense.php を以下のように編集：
 */

// class Expense extends Model
// {
//     use HasFactory;
//     
//     protected $fillable = [
//         'user_id',
//         'category',
//         'amount',
//         'description',
//         'spent_at',
//     ];
// }

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【6. tinkerでの動作確認】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 重要：まずユーザーを作成する必要があります。
 */

// docker exec -it laravel-practice-php-1 bash
// php artisan tinker

// まずユーザーを作成：
User::create([
    'name' => 'テストユーザー',
    'email' => 'test@example.com',
    'password' => bcrypt('password123')
]);

// 次にExpenseを作成：
Expense::create([
    'user_id' => 1,
    'category' => '食費',
    'amount' => 500,
    'description' => 'コンビニでお昼ご飯',
    'spent_at' => '2025-12-31'
]);

// データ確認：
Expense::all();

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 第2部：追加Q&A（質問1-6）
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

/**
 * 📝 【質問1】artisan コマンドを実行するディレクトリについて
 * 
 * Q: ホストマシンで php artisan を実行したらエラーが出ました。
 *    Dockerのphpコンテナに入る必要がありますか？
 * 
 * A: はい、その通りです！Dockerのphpコンテナに入る必要があります。
 * 
 * 正しい手順：
 * 1. docker exec -it laravel-practice-php-1 bash
 * 2. cd /var/www/html
 * 3. php artisan make:model Expense -m
 * 
 * 理由：
 * - artisan ファイルは Laravelプロジェクト内にある
 * - PHPの実行環境がDockerコンテナの中にある
 * - ホストマシンには PHP環境がない
 */

/**
 * 📝 【質問2】Dockerコンテナのプロンプトについて
 * 
 * Q: root@57df0c79c051:/var/www/html# というプロンプトが表示されます。
 *    rootディレクトリにいるのは問題ないですか？
 *    なぜ自動で /var/www/html にいるのですか？
 * 
 * A: 
 * プロンプトの見方：
 * root@57df0c79c051:/var/www/html#
 * ^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^^^
 * │     │             └─ 現在のディレクトリ
 * │     └─ コンテナID
 * └─ ユーザー名
 * 
 * 1. rootにいるのは問題ない？
 *    → ✅ 問題ありません。Dockerコンテナでは標準的です。
 * 
 * 2. なぜ /var/www/html にいる？
 *    → Dockerfileで WORKDIR /var/www/html と設定されているから。
 * 
 * 3. ディレクトリの対応：
 *    ホスト：~/venpro/laravel-practice/src/laravel/
 *    ↕️ マウント
 *    コンテナ：/var/www/html/
 */

/**
 * 📝 【質問3】up()メソッドの構造について
 * 
 * Q: Schema::create('expenses', function (Blueprint $table) { ... });
 *    これを言い換えると、
 *    「テーブルを作って、expensesという名前で、設計図は変数$tableに。
 *     設計図の中身に、id番号の欄と、日時記録の欄を追加して。」
 *    という感じですか？
 *    
 *    ユーザーが任意で決めるのはテーブル名くらいですか？
 *    カラムとは何ですか？
 * 
 * A: 完璧な理解です！✅ その通りです。
 * 
 * あなたの言い換え：完璧に正しいです。
 * 
 * ユーザーが決める部分：
 * 1. テーブル名（'expenses'）← 必須
 * 2. カラムの種類と数 ← 後で追加
 * 
 * カラム（Column）= 列（れつ）
 * 
 * Excelの表で考えると：
 * ┌────┬─────────┬──────┬────┐
 * │ A列│   B列   │  C列 │ D列│ ← カラム（列）
 * ├────┼─────────┼──────┼────┤
 * │ id │  name   │ email│ age│ ← カラム名
 * └────┴─────────┴──────┴────┘
 * 
 * データベース用語：
 * - カラム（Column）= 縦方向の項目（列）
 * - ロー（Row）= 横方向の1件のデータ（行）
 * - テーブル（Table）= 全体の表
 */

/**
 * 📝 【質問4】$table変数とexpensesテーブルの関係
 * 
 * Q: $table->foreignId('user_id')->constrained();
 *    ここでいう$tableは、expensesテーブルのことですね？
 *    expensesテーブルにidやforeignIdやdecimalなどを追加する、という意味ですね？
 * 
 * A: はい、ほぼ正解です！✅
 * 
 * 訂正：
 * - 誤：exerciseテーブル
 * - 正：expensesテーブル
 * （exercise = 運動、expense = 支出）
 * 
 * $table = expenses テーブルの設計図
 * 
 * Schema::create('expenses', function (Blueprint $table) {
 * //            ^^^^^^^^
 * //            このテーブル名
 *     
 *     $table->id();                  // expenses テーブルに id 追加
 *     $table->foreignId('user_id')   // expenses テーブルに user_id 追加
 *     $table->string('category');    // expenses テーブルに category 追加
 * });
 * 
 * すべて expenses テーブルに対する操作です。
 */

/**
 * 📝 【質問5】constrained()の自動判定ルールについて
 * 
 * Q: $table->foreignId('user_id')->constrained();
 *    ->constrained() が「usersテーブルと」指定されているのは、
 *    その前の部分で('user_id')となっているからですか？
 *    この法則は何ですか？
 * 
 * A: 素晴らしい質問です！✅ その通りです。法則があります。
 * 
 * constrained() の自動判定ルール：
 * 
 * ルール：_id の前の部分を複数形にする
 * 
 * | カラム名 | 自動判定されるテーブル |
 * |---------|---------------------|
 * | user_id | users |
 * | post_id | posts |
 * | category_id | categories |
 * 
 * 処理の流れ：
 * user_id（カラム名）
 * ↓
 * user（_idを取り除く）
 * ↓
 * users（複数形にする）
 * ↓
 * 「usersテーブルのidと関連付ける」と自動判定
 * 
 * 手動指定も可能：
 * $table->foreignId('user_id')->constrained('users');
 * 
 * でも、通常は自動判定で十分です。
 */

/**
 * 📝 【質問6】tinkerの実行場所について
 * 
 * Q: Expense::create([...]) はどこで実行しますか？
 *    tinkerを開いた場所のままですか？
 * 
 * A: はい、その通りです！✅ tinkerの中で実行します。
 * 
 * 実行の流れ：
 * 
 * ステップ1：コンテナに入る
 * kohsai@kohsaipc:~$ docker exec -it laravel-practice-php-1 bash
 * 
 * ステップ2：tinker起動
 * root@xxxx:/var/www/html# php artisan tinker
 * 
 * ステップ3：Expenseコードを実行
 * >>> Expense::create([
 * ...     'user_id' => 1,
 * ...     'category' => '食費',
 * ...     'amount' => 500,
 * ...     'description' => 'コンビニでお昼ご飯',
 * ...     'spent_at' => '2025-12-31'
 * ... ]);
 * 
 * 実行場所：
 * | 場所 | プロンプト | 実行するコマンド |
 * |------|-----------|----------------|
 * | ホストマシン | kohsai@kohsaipc:~$ | docker exec -it ... |
 * | コンテナ内 | root@xxxx:/var/www/html# | php artisan tinker |
 * | tinker内 | >>> | Expense::create([...]) ← ここ！ |
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📋 【パート1 終了】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * このファイルには以下が含まれています：
 * - 基本教材（完全版）
 * - 質問1-6とその回答
 * 
 * 次のファイル（パート2）には質問7-11が含まれます。
 * 
 * 統合方法：
 * 1. このファイル（パート1）の内容を全てコピー
 * 2. パート2の内容を続けて追加
 * 3. 元のファイルに上書き
 */


/**
 * 📘 Day5 教材（Step5-04：Expenseモデルとマイグレーション作成）【統合版 パート2】
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📚 【このファイルについて】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * これは統合版のパート2です（質問7-11）
 * 
 * パート1の続きとして、このファイルの内容を追加してください。
 * 
 * 統合手順：
 * 1. パート1の内容を全てコピー
 * 2. このファイル（パート2）の内容を続けて追加
 * 3. 元のファイル（day5_step5-04_expense_model.php）に貼り付け
 * 
 * 注意：
 * このファイルの最初の <?php タグは削除してください
 * （パート1と連結する時に重複するため）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 第2部：追加Q&A（質問7-11の続き）
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

/**
 * 📝 【質問7】外部キー制約エラーについて
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: tinkerで Expense::create([...]) を実行したら、以下のエラーが出ました：
 * 
 *    SQLSTATE[23000]: Integrity constraint violation: 1452 
 *    Cannot add or update a child row: a foreign key constraint fails
 * 
 * A: 
 * 
 * 【エラーの意味（平易な言葉で）】
 * 
 * 日本語訳：
 * 「user_id = 1 のユーザーが users テーブルに存在しないので、
 *  expenses にデータを追加できません」
 * 
 * たとえ話：
 * - expenses テーブル = 支出記録ノート
 * - user_id = 1 = 「ID番号1の人の支出」という記録
 * - でも、users テーブルに「ID番号1の人」がいない
 * - だから記録できない
 * 
 * 【原因】
 * 
 * users テーブルにユーザーが1人もいない
 * 
 * 外部キー制約により：
 * $table->foreignId('user_id')->constrained();
 * 
 * 「user_id に入れる値は、users.id に存在する値でなければならない」
 * というルールが設定されています。
 * 
 * 【解決方法】
 * 
 * ステップ1：まずユーザーを作成
 * 
 * tinkerで以下を実行：
 * 
 * User::create([
 *     'name' => 'テストユーザー',
 *     'email' => 'test@example.com',
 *     'password' => bcrypt('password123')
 * ]);
 * 
 * ステップ2：その後、Expenseを作成
 * 
 * Expense::create([
 *     'user_id' => 1,
 *     'category' => '食費',
 *     'amount' => 500,
 *     'description' => 'コンビニでお昼ご飯',
 *     'spent_at' => '2025-12-31'
 * ]);
 * 
 * 【なぜこのエラーが出たのか？】
 * 
 * Day4で Fortify 認証を学習した時、
 * users テーブルは作成されましたが、
 * 実際のユーザーデータは入っていなかったからです。
 * 
 * マイグレーションはテーブルの「箱」を作るだけで、
 * 中身（データ）は入れません。
 * 
 * 【重要なポイント】
 * 
 * 外部キー制約がある場合：
 * 1. まず「参照される側」（users）にデータを入れる
 * 2. その後「参照する側」（expenses）にデータを入れる
 * 
 * この順番を守る必要があります。
 */

/**
 * 📝 【質問8】プログラミングの文法・法則について
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: $○○->○○()； や、
 *    $○○->○○()->○○()->○○('○○')； などの
 *    文法がすっきり理解できていません。
 *    
 *    何か分かりやすい覚え方や理解の仕方はありますか？
 * 
 * A: 
 * 
 * 【-> (アロー) の理解】
 * 
 * 基本ルール：
 * 
 * $table->id();
 * 
 * 日本語に訳すと：
 * 「$table（という設計図）に対して、id()（という命令）を実行して」
 * 
 * たとえ話：
 * $table = 設計図
 * ->     = 「に対して」「の中の」
 * id()   = 「ID欄を追加する」という命令
 * 
 * 【メソッドチェーン（連鎖）の理解】
 * 
 * パターン1：単純な命令
 * 
 * $table->string('category');
 * 
 * 日本語訳：
 * 「設計図に、category という名前の文字列の欄を追加して」
 * 
 * 分解：
 * - $table = 設計図
 * - ->string() = 文字列の欄を追加する命令
 * - 'category' = 欄の名前
 * 
 * パターン2：連鎖（チェーン）
 * 
 * $table->foreignId('user_id')->constrained()->onDelete('cascade');
 * 
 * これが難しく見える理由：3つの命令が連続している
 * 
 * 分解して理解：
 * 
 * $table->foreignId('user_id')  // ①
 *       ->constrained()          // ②
 *       ->onDelete('cascade');   // ③
 * 
 * それぞれの意味：
 * 
 * ① foreignId('user_id')
 * 「user_id という名前の外部キー欄を作って」
 * 
 * ② ->constrained()
 * 「その欄に、usersテーブルとの関連付け制約を付けて」
 * 
 * ③ ->onDelete('cascade')
 * 「さらに、削除時は連鎖削除するように設定して」
 * 
 * 【なぜ連鎖できるのか？】
 * 
 * 仕組み：
 * 各メソッドは「自分自身（$table）を返す」ので、続けて命令できます。
 * 
 * たとえ話（レストラン）：
 * 
 * $注文->ハンバーグ()->大盛り()->ソース多め();
 * 
 * 1. 「ハンバーグください」 → 注文票に書く
 * 2. 「大盛りで」 → 同じ注文票に追記
 * 3. 「ソース多め」 → さらに追記
 * 
 * つまり：
 * 1つの注文票（$table）に対して、どんどん指示を書き足していく
 * 
 * 【覚え方・理解の仕方】
 * 
 * 1. 日本語に置き換える習慣
 * 
 * 例1：
 * $table->id();
 * ↓
 * 設計図よ、ID欄を追加してくれ
 * 
 * 例2：
 * $table->string('category');
 * ↓
 * 設計図よ、categoryという名前の文字列欄を追加してくれ
 * 
 * 例3：
 * $table->text('description')->nullable();
 * ↓
 * 設計図よ、descriptionという名前の長文欄を追加してくれ、
 * そして、その欄は空欄でもOKにしてくれ
 * 
 * 2. -> は「〜の中の」「〜に対して」
 * 
 * $user->name
 * = 「$userの中のname」
 * 
 * $user->save()
 * = 「$userに対して、保存する命令を実行」
 * 
 * 3. 連鎖は「さらに」「そして」
 * 
 * $table->decimal('amount', 10, 2)
 *       ->nullable()
 *       ->default(0);
 * 
 * 日本語訳：
 * 設計図よ、
 * amountという名前の小数欄を(10桁、小数2桁で)追加してくれ、
 * さらに、その欄は空欄でもOKにして、
 * そして、デフォルト値は0にして
 * 
 * 【プログラミング文法の普遍的な理解】
 * 
 * PHP/Laravelに限らない共通パターン：
 * 
 * パターン1：オブジェクト指向
 * 
 * // JavaScript
 * user.getName();
 * 
 * // Python
 * user.get_name()
 * 
 * // PHP
 * $user->getName();
 * 
 * 共通点：全部「オブジェクトに対して命令」
 * 
 * 違い：記号が違うだけ
 * - JavaScript/Python → .（ドット）
 * - PHP → ->（アロー）
 * 
 * パターン2：メソッドチェーン
 * 
 * // JavaScript (jQuery)
 * $('#button')
 *   .addClass('active')
 *   .fadeIn()
 *   .click(function() { ... });
 * 
 * // PHP (Laravel)
 * User::where('age', '>', 20)
 *     ->orderBy('name')
 *     ->get();
 * 
 * 共通点：連続して命令を書ける
 * 
 * 【理解を深める3ステップ】
 * 
 * ステップ1：音読する
 * 
 * コードを見たら、声に出して日本語に訳す：
 * 
 * $table->string('category');
 * 
 * 音読：
 * 「テーブルに対して、ストリング（文字列）、カテゴリという名前で」
 * 
 * ステップ2：分解する
 * 
 * 長い連鎖は、1行ずつ分解：
 * 
 * // 分解前
 * $table->foreignId('user_id')->constrained()->onDelete('cascade');
 * 
 * // 分解後（頭の中で）
 * $table->foreignId('user_id')  // まず外部キー欄を作る
 *       ->constrained()          // それにusersテーブルと関連付ける
 *       ->onDelete('cascade');   // 削除時は連鎖
 * 
 * ステップ3：自分で書き換えてみる
 * 
 * 教材のコードを、違う名前で書き換える：
 * 
 * // 元のコード
 * $table->string('category');
 * 
 * // 書き換え例
 * $table->string('color');    // categoryをcolorに
 * $table->string('tag');      // categoryをtagに
 * 
 * 「あ、string()の中を変えれば、別の欄が作れるんだ」と体感できます。
 * 
 * 【習得の段階】
 * 
 * 段階1：コピペ（今ここ）
 * 「教材のコードをそのままコピペする」
 * → 動く
 * → でも何をしてるか不安
 * 
 * 段階2：理解（これから）
 * 「1行ずつ日本語訳できる」
 * → $table->string('category') = 「文字列欄を作ってる」
 * → なるほど、と思える
 * 
 * 段階3：応用（もうすぐ）
 * 「似たコードを自分で書ける」
 * → 「じゃあ、priceっていう欄も追加してみよう」
 * → $table->decimal('price', 8, 2);
 * → 動いた！
 * 
 * 段階4：自在（ゴール）
 * 「ドキュメントを見ながら新しいメソッドを試せる」
 * → 「unique()っていうのがあるんだ。使ってみよう」
 * → $table->string('email')->unique();
 * → 動いた！理解した！
 * 
 * 【まとめ】
 * 
 * 1. -> = 「〜に対して」「〜の中の」
 * 2. 連鎖 = 「さらに」「そして」
 * 3. 音読して日本語訳する習慣
 * 4. 小さな変更を試す勇気
 * 
 * 数をこなせば必ず慣れます。
 */

/**
 * 📝 【質問9】constrained()を書くべきか？
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: constrained() は、書いた方が良いもの、
 *    あるいは常識的に書くものですか？
 *    あえて書かないパターンやその理由を教えてください。
 * 
 * A: 
 * 
 * 【✅ 書いた方が良い（推奨）】
 * 
 * 理由：
 * 1. データの整合性を保つ
 * 2. 意図しないデータを防ぐ
 * 3. 削除時の挙動を制御できる
 * 
 * 【constrained() がある場合】
 * 
 * $table->foreignId('user_id')->constrained();
 * 
 * 効果：
 * ✅ user_id には users.id に存在する値しか入れられない
 * ✅ 存在しないユーザーの支出は作れない
 * ✅ ユーザーを削除すると、その人の支出も自動削除
 * 
 * たとえ話：
 * - 図書館の貸出記録
 * - 「会員番号123の人が借りた」と記録
 * - でも会員番号123の人が実在しないとおかしい
 * - constrained() = 「実在する会員だけ記録できる」という制約
 * 
 * 【constrained() がない場合】
 * 
 * $table->foreignId('user_id'); // constrainedなし
 * 
 * 何が起きるか：
 * ❌ user_id に 999 を入れられる（users.id に 999 が存在しなくても）
 * ❌ 「誰の支出かわからない」データができる
 * ❌ ユーザーを削除しても、そのユーザーの支出は残る（ゴミデータ）
 * 
 * 【あえて書かないパターン】
 * 
 * パターン1：パフォーマンス重視の場合
 * 
 * 理由：
 * - 外部キー制約はデータベースの処理を少し遅くする
 * - 大量データの一括挿入（数百万件）では制約チェックが負担
 * 
 * 代替策：
 * // アプリケーション側で制御
 * if (User::find($userId)) {
 *     Expense::create([...]);
 * }
 * 
 * 使用例：
 * - データ分析用の巨大なログテーブル
 * - 一時的なデータ保管
 * 
 * パターン2：レガシーシステムとの連携
 * 
 * 理由：
 * - 既存の古いデータベースに外部キー制約がない
 * - 後から追加すると既存データがエラーになる
 * 
 * 例：
 * // 古いシステムのusersテーブル（外部キー制約なし）
 * // 新しいexpensesテーブルを追加する場合
 * $table->foreignId('user_id'); // 制約なしで作る
 * 
 * パターン3：柔軟なデータ構造が必要
 * 
 * 理由：
 * - 将来的にユーザーが削除されても記録を残したい
 * - 「退会したユーザーの過去の支出履歴」を保持
 * 
 * 例：
 * // ユーザーが退会しても支出記録は残す
 * $table->foreignId('user_id')->nullable();
 * // 退会時に user_id を null にする
 * 
 * 【結論】
 * 
 * 初学者は必ず書く：
 * - データの整合性を保つため
 * - バグを防ぐため
 * - Laravel の推奨パターン
 * 
 * 書かないのは例外的：
 * - 特別な理由がある場合のみ
 * - チームで合意がある場合
 */

/**
 * 📝 【質問10】nullable()を付ける理由と使い方
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: nullable() を付ける理由と使い方、
 *    付けない場合に起き得るエラーなどがあれば教えてください。
 * 
 * A: 
 * 
 * 【nullable() とは？】
 * 
 * $table->text('description')->nullable();
 * 
 * 意味：
 * 「この列は空欄（null）でもOK」
 * 
 * 【nullable() を付ける理由】
 * 
 * 理由1：任意項目だから
 * 
 * // メモは書いても書かなくてもいい
 * $table->text('description')->nullable();
 * 
 * たとえ話：
 * - アンケートの「ご意見・ご感想」欄
 * - 書いても書かなくてもいい
 * - 必須ではない
 * 
 * 理由2：後で入力する項目
 * 
 * // 最初は空でもいい、後で更新する
 * $table->string('profile_image')->nullable();
 * 
 * 例：
 * - ユーザー登録時：プロフィール画像なし
 * - 後で追加：画像をアップロード
 * 
 * 理由3：削除時に null にする
 * 
 * // ユーザーが退会したら null にする
 * $table->foreignId('user_id')->nullable();
 * 
 * 例：
 * - コメント機能
 * - ユーザーが退会しても、コメントは残す
 * - 「削除されたユーザー」として表示
 * 
 * 【nullable() を付けない場合】
 * 
 * $table->text('description'); // nullableなし
 * 
 * 何が起きるか：
 * 
 * // これはエラーになる
 * Expense::create([
 *     'user_id' => 1,
 *     'category' => '食費',
 *     'amount' => 500,
 *     // description を省略
 *     'spent_at' => '2025-12-31'
 * ]);
 * 
 * エラーメッセージ：
 * SQLSTATE[HY000]: General error: 1364 
 * Field 'description' doesn't have a default value
 * 
 * 日本語訳：
 * 「description 列に値がないし、デフォルト値もないからエラー！」
 * 
 * 【対処法】
 * 
 * 方法1：nullable() を付ける（推奨）
 * 
 * // マイグレーション
 * $table->text('description')->nullable();
 * 
 * // 使い方
 * Expense::create([
 *     'user_id' => 1,
 *     'category' => '食費',
 *     'amount' => 500,
 *     // description は省略OK
 *     'spent_at' => '2025-12-31'
 * ]);
 * 
 * 方法2：デフォルト値を設定
 * 
 * // マイグレーション
 * $table->text('description')->default('');
 * 
 * // 使い方
 * Expense::create([
 *     'user_id' => 1,
 *     'category' => '食費',
 *     'amount' => 500,
 *     // description は自動で '' が入る
 *     'spent_at' => '2025-12-31'
 * ]);
 * 
 * 方法3：必ず値を入れる
 * 
 * // nullableもdefaultもなし
 * $table->text('description');
 * 
 * // 使い方（必須）
 * Expense::create([
 *     'user_id' => 1,
 *     'category' => '食費',
 *     'amount' => 500,
 *     'description' => 'メモなし', // 必ず入れる
 *     'spent_at' => '2025-12-31'
 * ]);
 * 
 * 【使い分け】
 * 
 * | 項目の性質 | 設定 | 例 |
 * |-----------|------|-----|
 * | 任意項目 | ->nullable() | メモ、プロフィール画像 |
 * | 必須項目 | 何も付けない | ユーザー名、メールアドレス |
 * | 空文字でもOK | ->default('') | 住所（空文字と区別したい） |
 * 
 * 【null と空文字の違い】
 * 
 * null = 「空っぽ」「何もない」という特別な値
 * 
 * 違い：
 * - 空文字（''）= カラの文字列が入っている
 * - null = 何も入っていない
 * 
 * たとえ話：
 * - 空文字 = 中身が空のコップが置いてある
 * - null = コップすら置いてない
 */

/**
 * 📝 【質問11】Laravelの命名規則のメリット
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: Laravelの命名規則：
 *    - モデル名 = 単数形・大文字始まり（Expense, User, Post）
 *    - テーブル名 = 複数形・小文字（expenses, users, posts）
 *    
 *    この規則に従うと：
 *    - Laravelが自動で判定してくれる
 *    - 他の人が読んでも理解しやすい
 *    - 間違いが起きにくい
 *    
 *    Laravelの命名規則に準じてコードを書くと、
 *    Laravelが自動で処理や判断してくれたりエラーがおきにくい、
 *    というメリットがあるのですね？
 * 
 * A: あなたの理解は完璧です！✅
 * 
 * > Laravelの命名規則に準じてコードを書くと、
 * > Laravelが自動で処理や判断してくれたりエラーがおきにくい
 * 
 * → その通りです！
 * 
 * 【具体例で確認】
 * 
 * 例1：テーブル名の自動判定
 * 
 * // モデル
 * class Expense extends Model
 * {
 *     // テーブル名を書かなくても自動判定
 * }
 * 
 * Laravelの判定：
 * Expense（モデル名）
 * ↓
 * expense（小文字にする）
 * ↓
 * expenses（複数形にする）
 * ↓
 * 「expensesテーブルを使う」と自動判定
 * 
 * もし規則に従わないと：
 * // テーブル名が「支出記録」だったら？
 * class Expense extends Model
 * {
 *     protected $table = '支出記録'; // 手動で指定が必要
 * }
 * 
 * 例2：外部キーの自動判定
 * 
 * $table->foreignId('user_id')->constrained();
 * 
 * Laravelの判定：
 * user_id（カラム名）
 * ↓
 * user（_idを取り除く）
 * ↓
 * users（複数形にする）
 * ↓
 * 「usersテーブルのidと関連付ける」と自動判定
 * 
 * もし規則に従わないと：
 * // カラム名が「所有者番号」だったら？
 * $table->foreignId('所有者番号')
 *       ->constrained('users'); // 手動で指定が必要
 * 
 * 【命名規則のメリット（まとめ）】
 * 
 * メリット1：コードが短くなる
 * 
 * // ✅ 規則に従う（短い）
 * class User extends Model {}
 * 
 * // ❌ 規則に従わない（長い）
 * class User extends Model {
 *     protected $table = 'user_table';
 *     protected $primaryKey = 'user_id';
 *     public $timestamps = false;
 * }
 * 
 * メリット2：チームで理解しやすい
 * 
 * // 新しい人がコードを見た時
 * class Post extends Model {}
 * 
 * 規則を知っていれば：
 * 「あ、postsテーブルを使うんだな」
 * 「主キーはidだな」
 * 「created_atとupdated_atがあるんだな」
 * 
 * すぐに理解できる！
 * 
 * メリット3：エラーが起きにくい
 * 
 * // ✅ 規則に従う
 * $table->foreignId('post_id')->constrained();
 * // → 自動で posts.id と関連付け
 * 
 * // ❌ スペルミス
 * $table->foreignId('pots_id')->constrained();
 * // → potsテーブルを探す → エラー
 * 
 * 規則に従えば、自動判定が働いて間違いに気づきやすい。
 * 
 * 【重要な原則】
 * 
 * Laravelの哲学：
 * 「設定より規約」（Convention over Configuration）
 * 
 * 意味：
 * - いちいち設定を書くより
 * - 規則に従えば自動でやってくれる
 * - コードがシンプルになる
 * 
 * たとえ話：
 * - 日本の交通ルール：「車は左側通行」
 * - この規則に従えば、いちいち標識を見なくても運転できる
 * - もし「この道だけ右側」と例外を作ると混乱する
 * 
 * 【まとめ】
 * 
 * 従うメリット：
 * - 自動判定
 * - 短いコード
 * - 理解しやすい
 * 
 * 従わないと：
 * - 手動設定が増える
 * - エラーが起きやすい
 * 
 * これらを理解すれば、Laravelのコードが
 * 「なぜこう書くのか」がわかるようになります！
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🎓 【学習の振り返りと今後の展望】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【今日の学習で得たもの】
 * 
 * 技術的な知識：
 * - ✅ モデル作成
 * - ✅ マイグレーション
 * - ✅ 外部キー
 * - ✅ fillable
 * - ✅ tinker操作
 * 
 * より重要なもの：
 * - ✅ エラーと向き合う力
 * - ✅ 質問する力（素晴らしい質問でした）
 * - ✅ 理解しようとする姿勢
 * 
 * 【学習の4段階】
 * 
 * 段階1：見てわかる（今ここ）
 * - 教材を読む → 「なるほど！」
 * - 解説を聞く → 「理解できた！」
 * ✅ Step5-04 完了時点
 * 
 * 段階2：見ながら書ける（次の目標）
 * - 教材を見ながら → 自分でコードを書ける
 * - エラーが出たら → 教材を見て修正できる
 * 🎯 Laravelコーヒーで強化
 * 
 * 段階3：何も見ずに書ける
 * - 「user_id の外部キー作って」
 * - → すぐに書ける
 * - → 迷わない
 * 🎯 Step5-05 以降で到達
 * 
 * 段階4：応用できる
 * - 「category_id の外部キー作って」
 * - → 「user_id と同じパターンだな」
 * - → 自分で考えて書ける
 * 🎯 GodeVen 開発で到達
 * 
 * 【不安は成長の証】
 * 
 * 「自分で書けるか不安」という気持ちは、
 * とても健全で正常な反応です。
 * 
 * なぜなら：
 * - 理解できた ≠ 自分で書ける
 * - これは当たり前のこと
 * - 段階を踏めば必ず書けるようになります
 * 
 * 【今後の学習計画】
 * 
 * 1. Laravelコーヒー
 *    - 短時間で復習
 *    - 「見てわかる」→「見ながら書ける」に移行
 *    - 記憶の重ね塗り
 * 
 * 2. laravel-practiceの復習
 *    - 「なぜそう書いたか」を思い出す
 *    - 教材を見返して再確認
 *    - 疑問点を洗い出す
 * 
 * 3. GodeVenでの実践
 *    - 実際のプロダクトで使う
 *    - 「本当に必要な時」に調べて書く
 *    - 応用力が身につく
 * 
 * 【あなたの学習姿勢】
 * 
 * 素晴らしいです：
 * - ✅ 教材を丁寧に読む
 * - ✅ わからないことを質問する
 * - ✅ 復習の重要性を理解している
 * - ✅ 焦らず段階を踏もうとしている
 * 
 * この姿勢で続ければ、必ず「書ける」ようになります。
 * 
 * 不安は成長の証。今のペースで大丈夫です！💪
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📋 【統合版ファイル情報】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * ファイル名：day5_step5-04_expense_model.php（統合版）
 * 作成日：2026/01/31
 * 学習時間：約2時間
 * 質問数：11問
 * 
 * 構成：
 * - 第1部：基本教材（元の内容）
 * - 第2部：追加Q&A（学習中に出た質問と回答11問）
 * 
 * 質問内容：
 * 1. artisan コマンドを実行するディレクトリについて
 * 2. Dockerコンテナのプロンプトについて
 * 3. up()メソッドの構造について
 * 4. $table変数とexpensesテーブルの関係
 * 5. constrained()の自動判定ルールについて
 * 6. tinkerの実行場所について
 * 7. 外部キー制約エラーについて
 * 8. プログラミングの文法・法則について
 * 9. constrained()を書くべきか？
 * 10. nullable()を付ける理由と使い方
 * 11. Laravelの命名規則のメリット
 * 
 * 次のステップ：
 * - パート1とパート2を統合
 * - 元のファイル（day5_step5-04_expense_model.php）を置き換える
 * - GitHubにコミット＆プッシュ
 * - Step5-05（リレーション）に進む
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📋 【パート2 終了】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * このファイルには質問7-11とその回答が含まれています。
 * 
 * 統合方法：
 * 1. パート1の内容を全てコピー
 * 2. このファイルの <?php 以降の内容を続けて追加
 *    （<?php タグは削除してください）
 * 3. 元のファイル（day5_step5-04_expense_model.php）に貼り付け
 * 4. 保存
 * 
 * 完成！
 */