<?php

/**
 * 📘 Day5 教材（Step5-02：Eloquent基本操作 - データの取得・検索）
 * 
 * この教材では「データベースからデータを取り出す方法」を学びます
 * 
 * 【この教材の構成】
 * ・第1部：基本教材（all, find, where, first の解説）
 * ・第2部：追加Q&A（学習中に出た質問と回答）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📚 【第1部：基本教材】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🧠 【今日学ぶこと】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Eloquent（エロクエント）という仕組みを使って、
 * データベースに保存されているデータを取り出す方法を学びます。
 * 
 * 【Eloquentって何？】
 * Eloquent = Laravelに最初から入っている「データベース操作ツール」
 * 
 * 普通、データベースを操作するには「SQL（エスキューエル）」という
 * 専門的な言語を書く必要があります。
 * でもEloquentを使えば、PHPの普通のコードでデータベースを操作できます。
 * 
 * 【たとえ話】
 * - データベース = 大きな図書館
 * - テーブル（users） = 図書館の中の「人物名簿」という本棚
 * - レコード（1人のユーザー情報） = 本棚に並んでいる1冊の本
 * - Eloquent = 司書さん（「この本取って」と頼むと持ってきてくれる）
 * 
 * 【今日学ぶ4つの命令】
 * 1. all()（オール） = 「全部ちょうだい」
 * 2. find()（ファインド） = 「ID番号○番の本をちょうだい」
 * 3. where()（ウェア） = 「〇〇という条件に合う本を探して」
 * 4. first()（ファースト） = 「条件に合う本の中で最初の1冊だけちょうだい」
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【実際に動かすときのルール】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * - tinker（ティンカー）というツールで実際に試します
 *   tinker = Laravelの「お試し実験場」みたいなもの
 * 
 * - SQLという難しい言語を書かなくてOK
 *   PHPのメソッド（命令）を繋げて書くだけ
 * 
 * - 結果は2種類の形で返ってきます：
 *   ① Collection（コレクション） = データの箱（複数のデータが入っている）
 *   ② Model（モデル） = 1つのデータ（1人分の情報など）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【1. all() - 全部のデータを取り出す】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * all()（オール） = 「全部ちょうだい」という命令
 * 
 * 【たとえ話】
 * 図書館の司書さんに「人物名簿の本を全部持ってきて」とお願いするイメージ
 * 
 * 【tinkerで試す】
 * User::all();
 * 
 * 【この命令の意味】
 * User（ユーザー） = ユーザー情報が入っている場所
 * ::（コロンコロン） = 「〜に対して」という意味の記号
 * all() = 「全部」
 * 
 * つまり「ユーザー情報を全部取ってきて」という意味
 * 
 * 【返ってくるもの】
 * Collection（コレクション） = データが複数入った箱
 * 配列（はいれつ）みたいなもので、中に複数のユーザー情報が入っています
 */

/**
 * 💡 【詳しい解説】
 * 
 * User::all() は、データベースに対して
 * 「SELECT * FROM users」（ユーザーテーブルから全部選んで）
 * というSQL命令を自動的に実行してくれます。
 * 
 * SQLを書かなくても、User::all() と書くだけで同じことができるんです。
 * 
 * 【Collection（コレクション）って何？】
 * Collection = 「データのコレクション（収集物）」
 * 配列の進化版みたいなもので、便利な機能がたくさん追加されています。
 * 
 * 【注意点】
 * データが100人、1000人と増えてくると、
 * 全部取ってくるのは時間がかかって大変になります。
 * そういう時は paginate()（ページネート）という別の命令を使います。
 * （これは後で学びます）
 * 
 * 【実際の使い道】
 * - ユーザー一覧ページを表示する
 * - セレクトボックス（選択肢）を作る
 * - 管理画面で全ユーザーを表示する
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【2. find() - ID番号で1人分のデータを取り出す】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * find()（ファインド） = 「探す」「見つける」という意味
 * ID番号を指定して、その人のデータだけを取り出します
 * 
 * 【たとえ話】
 * 図書館の司書さんに「背番号1番の本を持ってきて」とお願いするイメージ
 * 
 * 【tinkerで試す】
 * User::find(1);
 * 
 * 【この命令の意味】
 * User（ユーザー） = ユーザー情報が入っている場所
 * ::（コロンコロン） = 「〜に対して」
 * find(1) = 「ID番号が1の人を探して」
 * 
 * 【返ってくるもの】
 * Modelインスタンス（モデル・インスタンス） = 1人分のデータ
 * 見つからなかった場合は null（ヌル）= 「何もない」という意味
 * 
 * 【複数のID番号で探すこともできます】
 * User::find([1, 2, 3]);
 * 
 * [1, 2, 3] = 配列という形式で、複数のID番号を指定
 * 「ID番号が1、2、3の人たちを全員持ってきて」という意味
 */

/**
 * 💡 【詳しい解説】
 * 
 * User::find(1) は、データベースに対して
 * 「SELECT * FROM users WHERE id = 1」
 * （ユーザーテーブルからID番号が1の人を選んで）
 * というSQL命令を自動的に実行してくれます。
 * 
 * 【Modelインスタンスって何？】
 * Model（モデル） = データの「型」
 * インスタンス = 実際のデータ1つ
 * 
 * たとえ話：
 * - Model = クッキーの型
 * - インスタンス = 型で作った実際のクッキー1枚
 * 
 * 【見つからなかった場合】
 * 存在しないID番号（例：999）で検索すると null が返ってきます
 * null = 「空っぽ」「何もない」という意味
 * 
 * findOrFail()（ファインド・オア・フェイル）という命令もあります
 * これは見つからなかった場合にエラーページを表示します
 * （失敗したら fail = 失敗する）
 * 
 * 【実際の使い道】
 * - ユーザー詳細ページを表示する（例：プロフィール画面）
 * - 特定のユーザーの編集画面を開く
 * - 「このユーザーの情報を見たい」という時
 * 
 * 【tinkerで試してみよう】
 * $user = User::find(1);
 * echo $user->name;  // 「テストさん」と表示される
 * echo $user->email; // 「test@example.com」と表示される
 * 
 * $user->name の意味：
 * $user = 変数（データを入れる箱）
 * -> = 「の中の」という意味の記号
 * name = 名前
 * つまり「$userという箱の中の名前」という意味
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【3. where() - 条件を指定して探す】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * where()（ウェア） = 「〜という条件のところ」という意味
 * 条件を指定してデータを探します
 * 
 * 【たとえ話】
 * 図書館の司書さんに
 * 「メールアドレスが test@example.com の人の本を探して」
 * とお願いするイメージ
 * 
 * 【tinkerで試す】
 * User::where('email', 'test@example.com')->get();
 * 
 * 【この命令の意味】
 * User（ユーザー） = ユーザー情報が入っている場所
 * ::where() = 「〜という条件で」
 * 'email' = メールアドレスという項目
 * 'test@example.com' = この値
 * ->get() = 「取ってきて」という意味の命令
 * 
 * つまり「メールアドレスが test@example.com のユーザーを取ってきて」
 */

/**
 * 💡 【詳しい解説】
 * 
 * where() だけでは実行されません！
 * where() は「探す準備をする」だけです。
 * 最後に get() や first() をつけて初めて実行されます。
 * 
 * 【たとえ話】
 * where() = 「探しておいて」と司書さんに頼む
 * get() = 「じゃあ持ってきて」と言う
 * 
 * 両方言わないと、司書さんは準備だけして持ってきてくれません。
 * 
 * 【いろんな探し方】
 * 
 * 1. 「〜より大きい」で探す
 * User::where('id', '>', 0)->get();
 * 「ID番号が0より大きい人」= つまり全員
 * 
 * 2. 「〜を含む」で探す（あいまい検索）
 * User::where('name', 'like', '%テスト%')->get();
 * 「名前に『テスト』という文字が含まれる人」
 * %（パーセント） = ワイルドカード（何でもOKの記号）
 * 
 * 3. 複数の条件を組み合わせる
 * User::where('id', '>', 0)->where('email', 'test@example.com')->get();
 * 「ID番号が0より大きくて、なおかつメールアドレスが test@example.com の人」
 * 
 * 【返ってくるもの】
 * where() だけだと QueryBuilder（クエリビルダー）という「準備中の状態」が返ってきます
 * get() をつけると Collection（コレクション）= データの箱が返ってきます
 * 
 * 【実際の使い道】
 * - メールアドレスでユーザーを検索する
 * - 名前の一部で検索する（「山田」で検索すると「山田太郎」「山田花子」が出る）
 * - 登録日で絞り込む（「2024年に登録した人」など）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【4. first() - 条件に合う最初の1つだけ取り出す】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * first()（ファースト） = 「最初の」という意味
 * where() と組み合わせて、条件に合う最初の1つだけを取り出します
 * 
 * 【たとえ話】
 * 図書館の司書さんに
 * 「メールアドレスが test@example.com の人の本を探して、
 *  見つかったら最初の1冊だけ持ってきて」
 * とお願いするイメージ
 * 
 * 【tinkerで試す】
 * User::where('email', 'test@example.com')->first();
 * 
 * 【この命令の意味】
 * User::where('email', 'test@example.com') = 「この条件で探して」
 * ->first() = 「最初の1つだけちょうだい」
 * 
 * 【返ってくるもの】
 * Modelインスタンス = 1人分のデータ
 * 見つからなかった場合は null（ヌル）= 「何もない」
 */

/**
 * 💡 【詳しい解説】
 * 
 * first() と get() の違い：
 * - first() = 最初の1つだけ返す（Modelインスタンス）
 * - get() = 条件に合うものを全部返す（Collection）
 * 
 * 【たとえ話】
 * 条件に合う本が10冊あったとします
 * - get() = 10冊全部持ってくる
 * - first() = 最初の1冊だけ持ってくる
 * 
 * 【見つからなかった場合】
 * first() で見つからなかった場合は null が返ってきます
 * 
 * firstOrFail()（ファースト・オア・フェイル）という命令もあります
 * これは見つからなかった場合にエラーページを表示します
 * 
 * 【実際の使い道】
 * - ログイン処理（メールアドレスでユーザーを1人だけ探す）
 * - 重複チェック（「このメールアドレスは既に使われている？」と確認）
 * - 「条件に合うデータが1つだけあればいい」という時
 * 
 * 【tinkerで試してみよう】
 * $user = User::where('email', 'test@example.com')->first();
 * echo $user->name; // 「テストさん」と表示される
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 💡 【まとめ：4つの命令の使い分け】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 1. 全部取り出したい → all()
 *    User::all();
 *    「図書館の人物名簿を全部持ってきて」
 * 
 * 2. ID番号で1つ取り出したい → find()
 *    User::find(1);
 *    「ID番号が1の人のデータを持ってきて」
 * 
 * 3. 条件で探して全部取り出したい → where()->get()
 *    User::where('name', 'テストさん')->get();
 *    「名前がテストさんの人を全員持ってきて」
 * 
 * 4. 条件で探して最初の1つだけ取り出したい → where()->first()
 *    User::where('email', 'test@example.com')->first();
 *    「メールアドレスが test@example.com の人を1人だけ持ってきて」
 * 
 * 【覚え方】
 * - all = 全部（オール）
 * - find = 探す（ファインド）
 * - where = 〜のところ（ウェア）
 * - first = 最初（ファースト）
 * - get = 取得する（ゲット）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🔗 【次のStepとのつながり】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 今日学んだのは「読み取り（データを見る）」だけです。
 * 
 * 次のStep（5-03）では「書き込み（データを変える）」を学びます：
 * - create()（クリエイト） = 新しくデータを作る
 * - update()（アップデート） = データを変更する
 * - delete()（デリート） = データを削除する
 * 
 * 【GodeVenでの使い道をイメージ】
 * 今日学んだ「読み取り」と、次に学ぶ「書き込み」を組み合わせると、
 * 実際に使えるアプリが作れるようになります！
 * 
 * - User::all() → ユーザー一覧ページを表示
 * - User::find($id) → ユーザー詳細ページを表示
 * - User::where('email', $email)->first() → ログイン処理
 * - create() → 新規ユーザー登録
 * - update() → ユーザー情報の編集
 * - delete() → ユーザーの削除
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【実践：tinkerで試そう】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * tinker（ティンカー） = Laravelの「お試し実験場」
 * ここで実際にコマンドを打って動作を確認できます
 * 
 * 【tinkerの起動方法】
 * ターミナル（黒い画面）で以下のコマンドを実行：
 * docker exec -it laravel-practice-php-1 php artisan tinker
 * 
 * 【順番に試してみよう】
 * 
 * 1. 全ユーザーを取得
 * User::all();
 * → 全員分のデータが表示されます
 * 
 * 2. ID=1のユーザーを取得
 * User::find(1);
 * → ID番号が1の人のデータが表示されます
 * 
 * 3. 名前を表示
 * $user = User::find(1);
 * echo $user->name;
 * → 「テストさん」と表示されます
 * 
 * 4. メールアドレスで検索
 * User::where('email', 'test@example.com')->first();
 * → test@example.com という人のデータが表示されます
 * 
 * 5. 複数条件で検索
 * User::where('id', '>', 0)->where('email', 'test@example.com')->get();
 * → 「ID番号が0より大きくて、メールアドレスが test@example.com の人」
 * 
 * 【tinkerの終了方法】
 * exit と入力するか、Ctrl+C（コントロールキーを押しながらC）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📝 【よくある質問】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q1. get() と all() の違いは何ですか？
 * A1. all() は「全部」を取る専用です。
 *     get() は where() などの条件をつけた後に使います。
 *     
 *     User::all(); → これはOK
 *     User::get(); → これもOK（結果は同じ）
 *     User::where('id', '>', 0)->all(); → これはエラー
 *     User::where('id', '>', 0)->get(); → これはOK
 * 
 * Q2. find() と first() の違いは何ですか？
 * A2. find() は「ID番号」で探します。
 *     first() は「条件」をつけて探した後、最初の1つを取ります。
 *     
 *     User::find(1); → ID番号1の人
 *     User::where('name', 'テストさん')->first(); → 名前で探して最初の1人
 * 
 * Q3. where() だけで実行できないのはなぜ？
 * A3. where() は「準備」だけで、実際には実行していません。
 *     最後に get() か first() をつけて初めて実行されます。
 *     
 *     たとえ話：
 *     where() = レストランで「メニューを見せて」と言う
 *     get() = 「じゃあこれを注文します」と言う
 *     メニューを見ただけでは料理は出てきません。注文して初めて出てきます。
 * 
 * Q4. データがない場合はどうなりますか？
 * A4. 命令によって返ってくるものが違います：
 *     - all() → 空のCollection（中身が空っぽの箱）
 *     - find() → null（何もない）
 *     - first() → null（何もない）
 *     - get() → 空のCollection（中身が空っぽの箱）
 * 
 * Q5. SQLを書かないのに動くのはなぜ？
 * A5. Eloquentが裏で自動的にSQLに変換して実行してくれるからです。
 *     
 *     たとえ話：
 *     あなた（PHP） → 「ID番号1の人を持ってきて」と日本語で頼む
 *     通訳（Eloquent） → 「SELECT * FROM users WHERE id = 1」とSQL語に翻訳
 *     データベース → SQL語を理解して、データを返す
 *     
 *     Eloquentが「通訳さん」の役割をしてくれるんです！
 * 
 * Q6. Collection（コレクション）って配列と何が違うの？
 * A6. Collectionは「配列の進化版」です。
 *     配列にできることは全部できて、さらに便利な機能がたくさん追加されています。
 *     
 *     普通の配列：シンプルな道具箱
 *     Collection：便利な機能がいっぱいついた道具箱
 *     
 *     例えば Collection には：
 *     - count() = 数を数える
 *     - first() = 最初の1つを取る
 *     - filter() = 条件で絞り込む
 *     など、便利なメソッド（命令）がたくさんあります。
 * 
 * Q7. :: と -> の違いは何ですか？
 * A7. どちらも「つなぐ」記号ですが、使う場面が違います。
 *     
 *     :: (コロンコロン) = クラス（設計図）に対して使う
 *     User::all() → Userという設計図に「全部ちょうだい」と頼む
 *     
 *     -> (アロー) = インスタンス（実際のデータ）に対して使う
 *     $user->name → $userという実際のデータの中の「名前」を見る
 *     
 *     たとえ話：
 *     :: = 図書館の受付カウンターで「全部の本のリストください」と頼む
 *     -> = 借りた本を開いて「この本のタイトルを見る」
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🎓 【用語集】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 今日出てきた用語をまとめて復習しましょう
 * 
 * Eloquent（エロクエント）
 * └─ Laravelに最初から入っている「データベース操作ツール」
 * 
 * tinker（ティンカー）
 * └─ Laravelの「お試し実験場」。コードを試せる場所
 * 
 * Model（モデル）
 * └─ データの「設計図」や「型」
 * 
 * インスタンス
 * └─ 設計図から作られた「実際のデータ1つ」
 * 
 * Collection（コレクション）
 * └─ 複数のデータが入った「箱」。配列の進化版
 * 
 * テーブル
 * └─ データベースの中の「表」。例：usersテーブル = ユーザー情報の表
 * 
 * レコード
 * └─ テーブルの中の「1行」= 1人分のデータ
 * 
 * カラム
 * └─ テーブルの中の「列」= データの項目（name、emailなど）
 * 
 * null（ヌル）
 * └─ 「何もない」「空っぽ」という意味
 * 
 * SQL（エスキューエル）
 * └─ データベースを操作するための専門言語
 * 
 * QueryBuilder（クエリビルダー）
 * └─ SQLを組み立てる途中の「準備中の状態」
 * 
 * メソッド
 * └─ 「命令」や「機能」のこと。all()、find()など
 * 
 * 引数（ひきすう）
 * └─ メソッドに渡す「材料」。find(1) の 1 が引数
 * 
 * 戻り値（もどりち）
 * └─ メソッドが返してくる「結果」
 * 
 * チェーン
 * └─ メソッドを「->」で繋げること
 *     where()->get() のように繋げて書く
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🤔 【第2部：学習中に出た質問と回答】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 以下は、この教材を学習中にKOHさんから出た質問と、
 * その回答をまとめたものです。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 1】なぜ%（パーセント）なのか
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: where('name', 'like', '%テスト%') の % は
 *    「何でもOKの記号」ということは分かりましたが、
 *    なぜ「%」なのですか？
 * 
 * A: 歴史的な理由です。
 * 
 * %（パーセント）は、SQL（エスキューエル）という言語が
 * **1970年代に作られたとき**から使われている記号です。
 * 
 * 【なぜ%を選んだのか】
 * - *（アスタリスク）は「掛け算」で使われていた
 * - ?（クエスチョン）は他の用途で使われていた
 * - %は比較的使われていなかった
 * - 「パーセント = 割合 = 何でもOK」という連想
 * 
 * 【他のプログラミング言語では】
 * - 正規表現（せいきひょうげん）では .*（ドット・アスタリスク）
 * - Windowsのファイル検索では *（アスタリスク）
 * - でもSQLでは %
 * 
 * つまり、**SQLを作った人たちが「%を使おう」と決めた**からです。
 * 
 * 【%の位置による違い（復習）】
 * 
 * 'テスト%'   → 「テスト」で始まる（テストさん ✅、山田テスト郎 ❌）
 * '%テスト'   → 「テスト」で終わる（鈴木花子テスト ✅、テストさん ❌）
 * '%テスト%'  → 「テスト」がどこかにある（全部 ✅）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 2】likeで完全一致させるとどうなる？
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: where('name', 'like', 'テストさん') とした場合、どうなりますか？
 *    「完全一致」と「のようなもの」は同じ式の中に共存しますか？
 * 
 * A: 動きますが、意味がありません。
 * 
 * 【結果】
 * where('name', 'like', 'テストさん')  // わざわざlikeを使う意味がない
 * where('name', '=', 'テストさん')     // こっちの方がシンプル
 * 
 * この2つは**同じ結果**になります。
 * 
 * 【たとえ話】
 * レストランで：
 * - 「このメニューと似たもの」と注文
 * - 結果的に同じものが出てくる
 * - 「このメニュー」と言えば済むのに、わざわざ「似たもの」と言ってる
 * 
 * 【「完全一致」と「のようなもの」の共存について】
 * 
 * 共存しません。どちらか一方を選びます：
 * 
 * // パターン1：完全一致
 * where('name', '=', 'テストさん')
 * 
 * // パターン2：あいまい検索
 * where('name', 'like', '%テスト%')
 * 
 * どちらか一方を使います。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 3】404エラーページの仕組み
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: よく見る「404 Not Found」ページは、
 *    こういうコード（findOrFail）のおかげで表示されているのですね？
 *    その後の処理を実行しないから、余計なエラーも発生しないのですか？
 * 
 * A: **完璧な理解です！**
 * 
 * 【何が起こっているか】
 * 
 * $user = User::findOrFail(999);  // 存在しないID
 * // ↑ここで処理を中断
 * // ↓この下のコードは実行されない
 * echo $user->name;
 * 
 * 1. findOrFail(999)を実行
 * 2. ID=999のユーザーを探す
 * 3. 見つからない
 * 4. **ここで処理を中断**
 * 5. 404ページを表示
 * 6. この下のコードは実行されない
 * 
 * 【OrFailを使わない場合】
 * 
 * $user = User::find(999);  // nullが返ってくる
 * echo $user->name;  // エラー！nullに対してnameを取れない
 * // → 分かりにくいエラーメッセージが出る
 * 
 * 【OrFailを使う場合】
 * 
 * $user = User::findOrFail(999);  // ここで404ページ
 * // → この下は実行されないから、余計なエラーが出ない
 * 
 * 【Webサイトで見る404ページ】
 * 
 * あなたがよく見る「404 Not Found」ページは：
 * - URLのミス（存在しないページ）
 * - 削除された記事を開こうとした
 * - **または、findOrFail()で見つからなかった**
 * 
 * すべて同じ仕組みです！
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 4】get()とfirst()の違い（詳細）
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: get()で取得したのは「任意の配列だけ」だから、
 *    合致しない配列（name）は見つけられずエラーになる、
 *    ということですか？
 * 
 * A: 少し理解が惜しいです。修正します。
 * 
 * 【正しい理解】
 * 
 * // get()を使った場合
 * $users = User::where('email', 'test@example.com')->get();
 * 
 * $usersの中身：
 * - Collection（箱）
 * - その箱の中に「1人分の全データ」が入っている
 * - でも「箱」なので、直接nameは取れない
 * 
 * 【たとえ話】
 * - 本を1冊だけ入れた「本棚」
 * - 本棚に対して「タイトル教えて」と言ってもダメ
 * - まず本棚から本を取り出して、その本のタイトルを見る必要がある
 * 
 * 【正しくはこう】
 * 
 * $users = User::where('email', 'test@example.com')->get();
 * // ↑Collection（箱）
 * 
 * // 箱から1人目を取り出す
 * $user = $users[0];  // または $users->first()
 * echo $user->name;  // OK！
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * // first()を使った場合
 * $user = User::where('email', 'test@example.com')->first();
 * 
 * $userの中身：
 * - 1人分の全データ（箱なし）
 * - 直接nameが取れる
 * 
 * 【たとえ話】
 * - 最初から「本」だけを持っている
 * - だから直接タイトルが見られる
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【まとめ表】
 * 
 * 命令      | 返ってくるもの        | 中身                | nameの取り方
 * ----------|---------------------|-------------------|---------------
 * get()     | Collection（箱）     | 複数の人（または1人）| $users[0]->name
 * first()   | Model（1人）         | 1人分の全データ      | $user->name
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【KOHさんの理解との違い】
 * 
 * > getで取得したのは（email, test@example.comなどの）任意の配列だけ
 * 
 * 違います。get()も**全データ**を取ってきています。
 * でも「箱に入っている」から、箱から出さないと中が見られません。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 5】first()を使う理由（万が一への備え）
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: 「メールアドレスは本来1つしかないはず」なのに、
 *    なぜfirst()を使うのですか？
 *    万が一に備えて念のため、ということですか？
 * 
 * A: **完璧な理解です！**
 * 
 * 【なぜfirst()を使うか】
 * 
 * 1. ✅ メールアドレスは本来1つのはず
 * 2. ✅ でも万が一複数あっても安全
 * 3. ✅ get()だと「箱」が返ってきて面倒
 * 4. ✅ first()なら直接データが取れて便利
 * 
 * 【プログラミングの鉄則】
 * 
 * 「起こらないはず」ではなく「もし起こったら」で考える
 * 
 * 【万が一のケース】
 * 
 * - システムのバグで重複登録されるかもしれない
 * - 将来、仕様変更で複数許可するかもしれない
 * - テストデータで同じメールを使ってるかもしれない
 * 
 * 【実際の使用例】
 * 
 * // ログイン処理
 * $user = User::where('email', $email)->first();
 * 
 * if ($user) {
 *     // パスワードが合ってるか確認
 *     if ($user->password == $password) {
 *         echo "ログイン成功";
 *     }
 * } else {
 *     echo "このメールアドレスは登録されていません";
 * }
 * 
 * // 重複チェック
 * $existing = User::where('email', $email)->first();
 * 
 * if ($existing) {
 *     echo "このメールアドレスは既に使われています";
 * } else {
 *     // 新しく登録OK
 * }
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 6】tinkerのコマンド実行場所
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: docker execコマンドを実行するのは、
 *    Laravelのルートディレクトリですか？
 *    特に指定はありますか？
 * 
 * A: **どこでも大丈夫です**
 * 
 * 【実行できる場所】
 * 
 * # ①Laravelのルートディレクトリ（src/laravel）
 * cd ~/venpro/laravel-practice/src/laravel
 * docker exec -it laravel-practice-php-1 php artisan tinker
 * 
 * # ②その上の階層（src）
 * cd ~/venpro/laravel-practice/src
 * docker exec -it laravel-practice-php-1 php artisan tinker
 * 
 * # ③さらに上（laravel-practice）
 * cd ~/venpro/laravel-practice
 * docker exec -it laravel-practice-php-1 php artisan tinker
 * 
 * # ④ホームディレクトリ
 * cd ~
 * docker exec -it laravel-practice-php-1 php artisan tinker
 * 
 * すべて同じ結果になります。
 * 
 * 【なぜどこでもOKなのか】
 * 
 * `docker exec` は「コンテナの中でコマンドを実行する」命令です。
 * 
 * 【たとえ話】
 * - あなたがいる場所 = 日本のどこか
 * - コンテナ = アメリカにある工場
 * - docker exec = アメリカの工場に電話をかけて「これやって」と頼む
 * 
 * あなたが日本のどこにいても、アメリカの工場に電話できますよね。
 * それと同じです。
 * 
 * 【推奨する場所】
 * 
 * おすすめ：Laravelのルートディレクトリ（src/laravel）
 * 
 * 理由：
 * - 他のLaravelコマンド（migrate、make:modelなど）も実行する
 * - 統一した方が混乱しない
 * - ファイル編集もしやすい
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 7】User::get()について
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: User::get(); は、
 *    whereで指定してないから、userという箱の中から
 *    全部（all）取り出せる、というイメージでしょうか？
 * 
 * A: **完璧な理解です！**
 * 
 * User::get(); は、
 * User::where('id', '>', 0)->get();
 * と実質的に同じです。
 * 
 * 【イメージ】
 * 
 * - User = ユーザー情報の箱
 * - get() = 「箱の中身を全部取り出して」
 * - 条件なし = 「特に選ばずに」
 * 
 * 【結果】
 * 
 * User::all();  // これと
 * User::get();  // これは同じ結果
 * 
 * 【違いは何か】
 * 
 * 実は、内部的には少し違いますが、**結果は同じ**です。
 * 
 * all() = 専用の「全部取る」命令
 * get() = 「条件に合うものを取る」命令（条件なし = 全部）
 * 
 * 【プログラマーの習慣】
 * 
 * - 全部取るなら all()
 * - 条件をつけるなら where()->get()
 * 
 * こうすると、コードを読む人が「あ、全部取ってるな」と分かりやすい。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 8】Collectionの歴史
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: Collectionって、Laravel（もしくはPHP）の歴史の中で、
 *    いつ頃から備わった機能ですか？
 * 
 * A: **2013年から**ある機能です。
 * 
 * 【Laravelでの歴史】
 * 
 * Laravel 3（2012年） → ❌ Collectionなし
 * Laravel 4（2013年） → ✅ **Collection登場！**
 * Laravel 5（2015年） → ✅ さらに強化
 * Laravel 11（2024年）→ ✅ 現在も使用中
 * 
 * つまり、約12年間使われている機能です。
 * 
 * 【PHPには】
 * 
 * - PHPそのものには「Collection」はない
 * - Laravelが独自に作った機能
 * - 他のフレームワーク（Symfony、CakePHPなど）にも似た機能がある
 * 
 * 【スクールで習わなかった理由】
 * 
 * 推測ですが：
 * - スクールでは「基本的な配列」を先に教える
 * - Collectionは「応用編」として後回し
 * - または、知らずに使っていた
 * 
 * 【実際の使用例】
 * 
 * // 今月の支出を全部取得
 * $expenses = Expense::where('month', '2025-11')->get();
 * 
 * // 食費だけ絞り込み
 * $food = $expenses->filter(function($expense) {
 *     return $expense->category == '食費';
 * });
 * 
 * // 食費の合計を計算
 * $total = $food->sum('amount');
 * echo "今月の食費：{$total}円";
 * 
 * 【今後の学習で】
 * 
 * - GodeVen開発で自然に使うようになる
 * - 「あ、これCollectionの機能だ」と気づく瞬間がくる
 * - そこで理解が深まります
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 9】::と->の理解
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: 「::」は、取ってくる前、もしくは探して取ってきたけど
 *    「まだ中身は見てない」状態と言えますか？
 *    「->（アロー）」は、取ってきた中身を「実際に見てる状態」と
 *    言えますか？
 * 
 * A: **ほぼ完璧です！99点**
 * 
 * 【::（コロンコロン）】
 * 
 * 正確には：
 * - 「クラス（設計図）に対して使う」
 * - 「まだデータを取っていない」または「静的な命令」
 * 
 * 例：
 * User::all();   // まだ取ってない、これから取る
 * User::find(1); // まだ取ってない、これから取る
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【->（アロー）】
 * 
 * **100点！完璧です**
 * 
 * - 取ってきた中身を「実際に見てる状態」
 * 
 * 例：
 * $user = User::find(1);  // ←ここで取ってきた
 * echo $user->name;       // ←取ったものの中を見てる
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【まとめ】
 * 
 * // ステップ1：クラス（設計図）に命令（::）
 * User::find(1)
 * // ↑「User」という設計図に「ID=1を探して」と頼む
 * 
 * // ステップ2：結果を箱に入れる
 * $user = User::find(1);
 * // ↑箱（$user）に1人分のデータが入った
 * 
 * // ステップ3：箱の中を見る（->）
 * echo $user->name;
 * // ↑箱の中の「name」という部分を見る
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 10】tinkerで確認したら実装しても安心？
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q: tinkerで確認しエラーが出ず動けば、
 *    基本的には実装しても安心というイメージでしょうか？
 * 
 * A: **基本的には安心ですが、100%ではありません**
 * 
 * 【安心できる部分（90%）】
 * 
 * // tinkerで動いた
 * User::where('email', 'test@example.com')->first();
 * // ↑この命令自体は正しい
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【まだ確認が必要な部分（10%）】
 * 
 * 1. **条件が違う場合**
 * 
 * // tinkerでは
 * User::where('email', 'test@example.com')->first();  // 動いた
 * 
 * // 実装では
 * User::where('email', $request->email)->first();
 * // $request->emailが空っぽかもしれない
 * 
 * 2. **データの状態が違う場合**
 * 
 * // tinkerでは：テストデータがある
 * // 本番では：まだユーザーが1人もいない
 * 
 * 3. **権限の問題**
 * 
 * // tinkerでは：管理者権限で実行
 * // 本番では：一般ユーザーとして実行
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【たとえ話】
 * 
 * 料理の試食：
 * - 味見では美味しかった（OK）
 * - でも「量」「盛り付け」「温度」はまだ確認してない
 * - お客さんに出す前に、全体を確認する
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【推奨する流れ】
 * 
 * 1. ✅ tinkerで命令を試す（基本的な動作確認）
 * 2. ✅ コントローラーに実装
 * 3. ✅ ブラウザで実際に動かす（実際の動作確認）
 * 4. ✅ いろんなパターンを試す（エラーケースも）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【追加Q&A 11】引数と戻り値
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 引数（ひきすう）と戻り値（もどりち）については、
 * まだ理解が確実ではないとのことでした。
 * 
 * 今後、Laravelコーヒーや練習問題で繰り返し出題して、
 * 確実に定着させていきましょう。
 * 
 * 【簡単な復習】
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【引数（ひきすう）】= 命令を実行するときの「材料」
 * 
 * find(1)  // ←この1が引数
 * 
 * たとえ話：
 * - find = 自動販売機
 * - 1 = ボタンを押す（「1番の商品ちょうだい」）
 * - 引数（1） = どの商品が欲しいか伝える材料
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【戻り値（もどりち）】= 命令を実行した後の「結果」
 * 
 * $user = User::find(1);  // ←$userに入るのが戻り値
 * 
 * たとえ話：
 * - ボタンを押した（find(1)）
 * - 商品が出てきた（ユーザー情報）
 * - 戻り値 = 出てきた商品（結果）
 * 
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【引数と戻り値の関係】
 * 
 * レストランのたとえ：
 * 
 * $料理 = 注文する('カレー');
 * //        ↑      ↑      ↑
 * //      命令   引数   戻り値
 * 
 * 1. **注文する** = 命令（メソッド）
 * 2. **'カレー'** = 引数（何が欲しいか）
 * 3. **$料理** = 戻り値（出てきた料理）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📝 【学習の記録】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * この教材は以下の流れで作成されました：
 * 
 * 1. 基本教材の作成（2025/11/26）
 * 2. KOHさんからの質問（11問）
 * 3. Klogeの回答
 * 4. 総合版として統合
 * 
 * このファイルには：
 * - 元の教材内容（完全版）
 * - 学習中に出た質問と回答（11問）
 * 
 * すべてが含まれています。
 */
