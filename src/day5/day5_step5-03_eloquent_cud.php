<?php

/**
 * 📘 Day5 教材（Step5-03：Eloquent基本操作 - データの作成・更新・削除）【総合版】
 * 
 * この教材では「データベースのデータを変更する方法」を学びます
 * 
 * 【構成】
 * 第1部：基本教材（元の内容）
 * 第2部：追加Q&A（学習中に出た質問と回答）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【第1部：基本教材】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🧠 【今日学ぶこと】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Step5-02では「データを見る（読み取り）」だけを学びました。
 * 今日は「データを変える（書き込み）」を学びます。
 * 
 * 【Step5-02とStep5-03の違い】
 * 
 * Step5-02（読み取り）= データを見るだけ
 * - all()（オール） = 全部見る
 * - find()（ファインド） = 1つ見る
 * - where()（ウェア） = 条件で探して見る
 * 
 * Step5-03（書き込み）= データを変える
 * - create()（クリエイト） = 新しく作る
 * - update()（アップデート） = 変更する
 * - delete()（デリート） = 削除する
 * 
 * 【たとえ話】
 * Step5-02 = 図書館の本を「読む」だけ
 * Step5-03 = 図書館の本を「追加・書き換え・処分」する
 * 
 * 【重要な違い】
 * - 読み取り = 何度やっても安全（データは変わらない）
 * - 書き込み = 慎重に！（データが実際に変わる）
 * 
 * 【今日学ぶ3つの命令】
 * 1. create()（クリエイト） = 新しいデータを作る
 * 2. update()（アップデート） = 既にあるデータを変更する
 * 3. delete()（デリート） = データを削除する
 * 
 * これらを合わせて「CUD（シーユーディー）」と呼びます。
 * 
 * 【CRUDって何？】
 * CRUD（クラッド）= データベース操作の基本4つ
 * - C = Create（クリエイト） = 作成
 * - R = Read（リード） = 読み取り ← Step5-02で学んだ
 * - U = Update（アップデート） = 更新
 * - D = Delete（デリート） = 削除
 * 
 * Step5-02でRを学んだので、今日はC・U・Dを学びます！
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【実際に動かすときのルール】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * - tinker（ティンカー）で実際に試します
 * - 今日の操作は「実際にデータが変わります」
 * - phpMyAdmin（ピーエイチピーマイアドミン）でも確認できます
 * 
 * 【注意点】
 * - テストデータを使って練習します
 * - 間違えて削除しても、また作り直せば大丈夫
 * - でも実務では慎重に！
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【1. create() - 新しいデータを作る】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * create()（クリエイト） = 「新しく作る」という命令
 * 
 * 【たとえ話】
 * 図書館に新しい本を追加するイメージ
 * 
 * 【この命令の意味】
 * User（ユーザー） = ユーザー情報の場所
 * ::（コロンコロン） = 「〜に対して」という記号
 * create() = 「新しく作る」
 * 
 * つまり「ユーザー情報を新しく作って」という意味
 */

/**
 * 【tinkerで試す】
 */

// 以下のコードをコピーしてtinkerで実行してください：
User::create([
    'name' => '山田太郎',
    'email' => 'yamada@example.com',
    'password' => bcrypt('password123')
]);

/**
 * → 新しいユーザーが作成されます
 * 
 * 【返ってくるもの】
 * Userインスタンス（作成されたユーザー情報）
 * 
 * 【重要な注意点：$fillable】
 * 
 * create()を使うには、Userモデルに「$fillable」という設定が必要です。
 * 
 * $fillable（フィラブル） = 「埋めてもOKな項目」のリスト
 * 
 * 【なぜ必要？】
 * セキュリティのため！
 * ユーザーが勝手に「管理者フラグ」などを設定できないようにする
 * 
 * 【Userモデルでの設定例】
 * protected $fillable = [
 *     'name',
 *     'email',
 *     'password',
 * ];
 * 
 * これで「name、email、passwordだけ埋めてOK」と指定
 */

/**
 * 【create()のもう1つの書き方】
 * 
 * Pattern 1: create()（一気に作る）
 * User::create(['name' => '太郎', 'email' => 'taro@example.com', 'password' => bcrypt('pass')]);
 * 
 * Pattern 2: new + save()（手順を分ける）
 * $user = new User();
 * $user->name = '太郎';
 * $user->email = 'taro@example.com';
 * $user->password = bcrypt('pass');
 * $user->save();
 * 
 * 【どちらを使う？】
 * - 簡潔に書きたい → create()
 * - 途中で処理を挟みたい → new + save()
 */

/**
 * 【実際の使い道】
 * - ユーザー登録機能
 * - 管理画面でのデータ追加
 * - インポート機能（CSVから一括登録など）
 */

/**
 * 【よくあるエラー】
 * 
 * エラー: "Add [name] to fillable property"
 * 原因: $fillableに項目を追加していない
 * 解決: Userモデルの$fillableに項目を追加
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【2. update() - データを更新する】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * update()（アップデート） = 「変更する」という命令
 * 
 * 【たとえ話】
 * 図書館の本の情報を書き換えるイメージ
 * 
 * 【この命令の意味】
 * 既にあるデータの一部を変更する
 */

/**
 * 【tinkerで試す】
 */

// 以下のコードをコピーしてtinkerで実行してください：
$user = User::find(1);
$user->update(['name' => '新しい名前']);

/**
 * → ID=1のユーザーの名前が変更されます
 * 
 * 【返ってくるもの】
 * true（成功）またはfalse（失敗）
 * 
 * 【update()の手順】
 * 1. まず対象を探す（find()やwhere()->first()）
 * 2. 見つかったデータに対してupdate()
 */

/**
 * 【update()のもう1つの書き方】
 * 
 * Pattern 1: update()（一気に更新）
 * $user->update(['name' => '新しい名前', 'email' => 'new@example.com']);
 * 
 * Pattern 2: 直接代入 + save()（手順を分ける）
 * $user->name = '新しい名前';
 * $user->email = 'new@example.com';
 * $user->save();
 * 
 * 【どちらを使う？】
 * - 複数項目を一気に更新 → update()
 * - 途中で条件分岐したい → 直接代入 + save()
 */

/**
 * 【実際の使い道】
 * - プロフィール編集機能
 * - 管理画面での情報修正
 * - ステータス変更（「申請中」→「承認済み」など）
 */

/**
 * 【重要な仕組み：updated_atの自動更新】
 * 
 * update()を使うと、updated_at（更新日時）が自動的に記録されます。
 * 
 * これにより「いつ変更されたか」が分かります。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【3. delete() - データを削除する】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * delete()（デリート） = 「削除する」という命令
 * 
 * 【たとえ話】
 * 図書館の本を処分するイメージ
 * 
 * 【この命令の意味】
 * データを完全に削除する
 */

/**
 * 【tinkerで試す】
 */

// 以下のコードをコピーしてtinkerで実行してください：
$user = User::find(2);
$user->delete();

/**
 * → ID=2のユーザーが削除されます
 * 
 * 【返ってくるもの】
 * true（成功）またはfalse（失敗）
 * 
 * 【重要な注意点】
 * delete()は「物理削除」です。
 * 
 * 物理削除（ぶつりさくじょ） = データベースから完全に消える
 * 復元できません！
 */

/**
 * 【削除の2つの方法】
 * 
 * 1. 物理削除（Physical Delete）
 *    → データベースから完全に削除
 *    → 復元不可能
 *    → delete()を使う
 * 
 * 2. 論理削除（Logical Delete / Soft Delete）
 *    → データは残したまま「削除済みフラグ」をつける
 *    → 復元可能
 *    → SoftDeletesという機能を使う（別のStepで学ぶ）
 * 
 * 【実務ではどちらを使う？】
 * - 個人情報など完全に消したい → 物理削除
 * - ユーザーが「退会」した場合 → 論理削除（復元の可能性）
 * - 投稿データなど → 論理削除（履歴として残す）
 */

/**
 * 【実際の使い道】
 * - ユーザー退会機能
 * - 管理画面でのデータ削除
 * - テストデータの削除
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 💡 【まとめ：読み取りと書き込みの使い分け】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【CRUD全体像】
 * 
 * Step5-02（読み取り）:
 * - all() = 全部見る
 * - find() = 1つ見る
 * - where()->get() = 条件で探して全部見る
 * - where()->first() = 条件で探して1つ見る
 * 
 * Step5-03（書き込み）:
 * - create() = 新しく作る
 * - update() = 変更する
 * - delete() = 削除する
 * 
 * 【実務での使い分け】
 * 
 * ユーザー一覧ページ:
 * User::all() → 読み取りのみ
 * 
 * ユーザー登録:
 * User::create([...]) → 書き込み
 * 
 * プロフィール編集:
 * $user = User::find($id); → 読み取り
 * $user->update([...]); → 書き込み
 * 
 * ユーザー削除:
 * $user = User::find($id); → 読み取り
 * $user->delete(); → 書き込み
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🔗 【次のStepとのつながり】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Step5-04以降でやること:
 * - Expenseモデルの作成
 * - UserとExpenseのリレーション定義
 * - 「1人のユーザーが複数の支出を持つ」という関係性
 * 
 * GodeVenでの応用:
 * - User::create() → ユーザー登録
 * - $user->expenses()->create() → その人の支出記録を作成
 * - $user->update() → プロフィール更新
 * - $expense->delete() → 支出記録を削除
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【実践：tinkerで試そう】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

/**
 * 以下のコマンドをターミナルで実行してtinkerを起動：
 * docker exec -it laravel-practice-php-1 php artisan tinker
 * 
 * tinker起動後、以下を順番に試してみてください：
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【1. 新規ユーザーを作成（create）】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

// 以下のコードをコピーしてtinkerで実行してください：
User::create([
    'name' => '山田太郎',
    'email' => 'yamada@example.com',
    'password' => bcrypt('password123')
]);

/**
 * → 新しいユーザーが作成されます
 * → 「id = 2」（または次の番号）で作成される
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【2. 全ユーザーを確認（all）】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

// 以下のコードをコピーしてtinkerで実行してください：
User::all();

/**
 * → 今作ったユーザーが表示されるか確認
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【3. 作成したユーザーを取得（find）】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

// 以下のコードをコピーしてtinkerで実行してください：
$user = User::find(2);
echo $user->name;

/**
 * → 「山田太郎」と表示される
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【4. 名前を変更（update）】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

// 以下のコードをコピーしてtinkerで実行してください：
$user = User::find(2);
$user->update(['name' => '山田花子']);

/**
 * → 名前が「山田花子」に変更される
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【5. 変更を確認（find）】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

// 以下のコードをコピーしてtinkerで実行してください：
$user = User::find(2);
echo $user->name;

/**
 * → 「山田花子」と表示される
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【6. ユーザーを削除（delete）】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

// 以下のコードをコピーしてtinkerで実行してください：
$user = User::find(2);
$user->delete();

/**
 * → ID=2のユーザーが削除される
 */

/**
 * 【phpMyAdminでも確認してみよう】
 * 
 * 1. ブラウザで http://localhost:8081 を開く
 * 2. データベース「laravel_practice」を選択
 * 3. テーブル「users」を開く
 * 4. データが増えたり減ったりしているのを確認
 */

/**
 * tinkerを終了する場合：
 * exit または Ctrl+C
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📝 【よくある質問】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q1. create()とnew + save()の違いは？
 * A1. 結果は同じ。create()は簡潔、new + save()は途中で処理を挟める。
 * 
 * Q2. update()で存在しない項目を指定したらどうなる？
 * A2. $fillableに含まれていない項目はエラーになる。
 * 
 * Q3. delete()したデータは復元できる？
 * A3. 物理削除なので復元不可。復元したいなら論理削除（SoftDelete）を使う。
 * 
 * Q4. 複数のデータを一気に削除できる？
 * A4. できる。User::where('status', 'inactive')->delete(); など。
 * 
 * Q5. created_atとupdated_atは自動で記録される？
 * A5. はい。create()でcreated_atが、update()でupdated_atが自動記録される。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📚 【用語集】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * CRUD（クラッド）
 * └─ Create / Read / Update / Delete の略
 * 
 * CUD（シーユーディー）
 * └─ Create / Update / Delete の略（今日学んだ3つ）
 * 
 * create()（クリエイト）
 * └─ 新しいデータを作成する命令
 * 
 * update()（アップデート）
 * └─ 既存データを更新する命令
 * 
 * delete()（デリート）
 * └─ データを削除する命令
 * 
 * $fillable（フィラブル）
 * └─ モデルで「埋めてもOKな項目」のリスト
 * 
 * Mass Assignment（マスアサインメント）
 * └─ 一括代入。セキュリティのため$fillableで制限する
 * 
 * 物理削除（ぶつりさくじょ / Physical Delete）
 * └─ データベースから完全に削除。復元不可。
 * 
 * 論理削除（ろんりさくじょ / Logical Delete / Soft Delete）
 * └─ データは残して「削除済みフラグ」をつける。復元可能。
 * 
 * bcrypt()（ビークリプト）
 * └─ パスワードを暗号化する関数
 * 
 * save()（セーブ）
 * └─ データを保存する命令（new後やプロパティ変更後に使う）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【第2部：追加Q&A】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 学習中にKOHさんから出た質問と、その回答を記録します。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【Q1. $fillableについて】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 質問：
 * 「$fillableは『埋めてOKな項目』のリストで、create()を使うときに必要」
 * とありますが、もう少し詳しく教えてください。
 * 
 * 回答：
 * 
 * $fillable = モデルのルール集の一部
 * 
 * 【何のため？】
 * セキュリティのため！
 * 悪意のあるユーザーが勝手に「管理者フラグ」などを設定できないようにする。
 * 
 * 【たとえ話】
 * あなたが飲み物の容器（ボトル）を持っているとします。
 * 
 * refill（リフィル）= 詰め替え
 * → 水やジュースを「入れ直す」
 * 
 * fillable（フィラブル）= 詰め替え可能な
 * → 「入れてもOK」という意味
 * 
 * つまり、$fillable = 「この項目は入れてもOKですよ」というリスト
 * 
 * 【Userモデルでの例】
 * 
 * protected $fillable = [
 *     'name',      // 名前は入れてOK
 *     'email',     // メールは入れてOK
 *     'password',  // パスワードは入れてOK
 * ];
 * 
 * 【もし$fillableがなかったら？】
 * 
 * 悪意のあるユーザーが以下のようなリクエストを送る可能性：
 * 
 * User::create([
 *     'name' => '太郎',
 *     'email' => 'taro@example.com',
 *     'password' => 'pass',
 *     'is_admin' => true  // ← 勝手に管理者になろうとする！
 * ]);
 * 
 * $fillableで制限していれば、is_adminは無視される。
 * 
 * 【まとめ】
 * - $fillable = セキュリティの守り
 * - create()を使うときに必須
 * - 「この項目は埋めてもOK」というリスト
 * 
 * 【語源】
 * fill（フィル）= 埋める、満たす
 * able（エイブル）= 〜できる
 * fillable = 埋めることができる
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【Q2. Postmanについて】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 質問：
 * 「Postmanがあれば、ブラウザ以外からもHTTPリクエストを送れる」
 * とありますが、どういうことですか？
 * 
 * 回答：
 * 
 * Postman（ポストマン）= API開発・テスト用のツール
 * 
 * 【Webの仕組み】
 * 
 * 通常、Webアプリは「ブラウザ → サーバー」でやり取りします：
 * 
 * ブラウザ（あなた） → HTTPリクエスト → サーバー（Laravel）
 * ブラウザ（あなた） ← HTTPレスポンス ← サーバー（Laravel）
 * 
 * でも実は、HTTPリクエストは「ブラウザ以外」からも送れます。
 * 
 * 【ブラウザ以外の送信元】
 * 
 * 1. Postman
 * 2. curl（コマンドラインツール）
 * 3. スマホアプリ
 * 4. 他のプログラム（PythonスクリプトなどJS）
 * 5. 悪意のあるツール ← これが問題！
 * 
 * 【悪意のある例】
 * 
 * 悪意のあるユーザーがPostmanや自作ツールで：
 * 
 * POST /users/create
 * {
 *   "name": "太郎",
 *   "email": "taro@example.com",
 *   "password": "pass",
 *   "is_admin": true  ← ブラウザのフォームにない項目を送る！
 * }
 * 
 * もし$fillableで制限していなければ、勝手に管理者になれてしまう。
 * 
 * 【Postmanの正しい使い方】
 * 
 * 開発者が自分のAPIをテストするツールとして使う：
 * 
 * - ログイン機能のテスト
 * - API動作確認
 * - スマホアプリ開発時のバックエンドテスト
 * 
 * 【まとめ】
 * - HTTPリクエストはブラウザ以外からも送れる
 * - だからこそ$fillableでセキュリティ対策が必要
 * - Postman = 開発者のテストツール（本来は悪用ツールではない）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【Q3. Fortifyインストール時の$fillable】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 質問：
 * Fortifyをインストールしたとき、$fillableは自動で記述されましたか？
 * 
 * 回答：
 * 
 * いいえ、$fillableは自動では記述されません。
 * 
 * 【Fortifyインストール時に自動で作られるもの】
 * 
 * 1. 認証ルート（/login、/registerなど）
 * 2. 認証処理のロジック
 * 3. マイグレーションファイル（usersテーブル等）
 * 
 * 【自分で書く必要があるもの】
 * 
 * 1. $fillable（Userモデル内）
 * 2. ビュー（login.blade.phpなど）← カスタマイズする場合
 * 
 * 【なぜ自動で書かれない？】
 * 
 * アプリによって「どの項目を埋めてOKにするか」が違うから。
 * 
 * 例：
 * - あるアプリ：name、email、password
 * - 別のアプリ：name、email、password、phone、address
 * 
 * だから、開発者が自分で決める必要がある。
 * 
 * 【Laravel標準のUserモデルには？】
 * 
 * 実は、Laravelの初期状態のUserモデルには、
 * すでに$fillableが書いてあります：
 * 
 * protected $fillable = [
 *     'name',
 *     'email',
 *     'password',
 * ];
 * 
 * これはLaravelプロジェクト作成時に自動生成される。
 * 
 * 【まとめ】
 * - Fortifyインストールでは$fillableは書かれない
 * - でもLaravelプロジェクト作成時に既に書いてある
 * - 新しい項目を追加するなら、自分で$fillableに追加する
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【Q4. 新しい項目を追加するとき】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 質問：
 * 新しい項目（例：phone）を追加するとき、
 * どこを変更すればいいですか？
 * 
 * 回答：
 * 
 * 3箇所を変更する必要があります。
 * 
 * 【変更する3箇所】
 * 
 * ⓵ 入力フォーム（register.blade.phpなど）
 * ⓶ データベース（マイグレーションファイル）
 * ⓷ モデル（$fillable）
 * 
 * 【具体的な手順】
 * 
 * ⓵ 入力フォーム（register.blade.php）
 * 
 * <input type="tel" name="phone" placeholder="電話番号">
 * 
 * ⓶ マイグレーションファイル
 * 
 * database/migrations/xxxx_create_users_table.php に追加：
 * 
 * $table->string('phone')->nullable();
 * 
 * そして実行：
 * php artisan migrate:fresh
 * 
 * ⓷ Userモデル（app/Models/User.php）
 * 
 * protected $fillable = [
 *     'name',
 *     'email',
 *     'password',
 *     'phone',  // ← 追加
 * ];
 * 
 * 【なぜ3箇所必要？】
 * 
 * - ⓵ フォーム = ユーザーが入力する場所
 * - ⓶ DB = データを保存する場所
 * - ⓷ $fillable = セキュリティの許可リスト
 * 
 * どれか1つでも欠けると動きません。
 * 
 * 【よくあるミス】
 * 
 * ミス1：フォームに追加したけど、$fillableに追加し忘れ
 * → エラー："Add [phone] to fillable property"
 * 
 * ミス2：$fillableに追加したけど、DBに追加し忘れ
 * → エラー："Column not found: 1054 Unknown column 'phone'"
 * 
 * 【まとめ】
 * 新しい項目を追加するなら、3箇所の整合性を確認！
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【Q5. 一括更新について】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 質問：
 * 複数のデータを一気に更新できますか？
 * 
 * 回答：
 * 
 * はい、できます。
 * 
 * 【方法1：where()->update()】
 * 
 * User::where('status', 'pending')->update(['status' => 'approved']);
 * 
 * 意味：
 * - statusが「pending」のユーザー全員を
 * - 「approved」に変更する
 * 
 * 【方法2：ループで1つずつ更新】
 * 
 * $users = User::where('status', 'pending')->get();
 * foreach ($users as $user) {
 *     $user->status = 'approved';
 *     $user->save();
 * }
 * 
 * 【どちらを使う？】
 * 
 * - シンプルな一括更新 → where()->update()
 * - 途中で条件分岐したい → ループ
 * 
 * 【注意点】
 * 
 * 一括更新は便利ですが、間違えると大変です。
 * 
 * 例：
 * User::update(['status' => 'banned']);
 * → 全ユーザーがbanされる！
 * 
 * 【安全に一括更新する方法】
 * 
 * 1. まず対象を確認
 * $users = User::where('status', 'pending')->get();
 * echo "更新対象：" . $users->count() . "件";
 * 
 * 2. 確認してから実行
 * User::where('status', 'pending')->update(['status' => 'approved']);
 * 
 * 3. 実行後に確認
 * $updated = User::where('status', 'approved')->count();
 * echo "更新完了：" . $updated . "件";
 * 
 * 【まとめ】
 * - 一括更新は可能
 * - でも慎重に！
 * - 必ず事前確認してから実行
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【Q6. SoftDeletesについて】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 質問：
 * SoftDeletes（論理削除）を設定し忘れたらどうなりますか？
 * 
 * 回答：
 * 
 * SoftDeletesを設定せずにdelete()を使うと、
 * 物理削除（完全削除）になります。
 * 
 * 【SoftDeletesとは】
 * 
 * データを実際には削除せず、
 * 「削除済みフラグ」をつけるだけ。
 * 
 * deleted_at（デリーテッドアット）というカラムに、
 * 削除日時を記録する。
 * 
 * 【SoftDeletesの設定方法】
 * 
 * ⓵ マイグレーションファイル
 * 
 * $table->softDeletes();
 * 
 * ⓶ モデル（User.php）
 * 
 * use Illuminate\Database\Eloquent\SoftDeletes;
 * 
 * class User extends Model
 * {
 *     use SoftDeletes;
 * }
 * 
 * 【設定し忘れた場合】
 * 
 * User::find(1)->delete();
 * → データベースから完全に削除される（復元不可）
 * 
 * 【SoftDeletes設定済みの場合】
 * 
 * User::find(1)->delete();
 * → deleted_atに削除日時が記録される
 * → データは残る（復元可能）
 * 
 * 【復元方法】
 * 
 * $user = User::withTrashed()->find(1);
 * $user->restore();
 * 
 * 【完全削除したい場合】
 * 
 * $user = User::withTrashed()->find(1);
 * $user->forceDelete();
 * 
 * 【実務での使い分け】
 * 
 * SoftDeletesを使うべき場合：
 * - ユーザーアカウント（退会しても履歴は残したい）
 * - 投稿データ（削除しても復元の可能性）
 * - 注文履歴（法律で保存義務がある場合）
 * 
 * 物理削除を使うべき場合：
 * - 個人情報（完全に削除する必要がある）
 * - テストデータ
 * - 一時ファイル
 * 
 * 【まとめ】
 * - SoftDeletesなし → 物理削除（復元不可）
 * - SoftDeletesあり → 論理削除（復元可能）
 * - チーム開発では、コメントで意図を明示すると良い
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【Q7. bcrypt()について】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 質問：
 * bcrypt()はなぜ必要ですか？
 * 
 * 回答：
 * 
 * bcrypt()（ビークリプト）= パスワードを暗号化する関数
 * 
 * 【なぜ必要？】
 * 
 * パスワードを平文（ひらぶん = そのままの文字）で保存すると危険！
 * 
 * 【危険な例】
 * 
 * User::create([
 *     'name' => '太郎',
 *     'email' => 'taro@example.com',
 *     'password' => 'password123'  // ← 平文で保存
 * ]);
 * 
 * もしデータベースが漏洩したら？
 * → パスワードが丸見え
 * 
 * 【bcrypt()を使った場合】
 * 
 * User::create([
 *     'name' => '太郎',
 *     'email' => 'taro@example.com',
 *     'password' => bcrypt('password123')
 * ]);
 * 
 * データベースには：
 * $2y$10$abcdefg...（暗号化された文字列）
 * 
 * → 元のパスワードは分からない
 * 
 * 【bcrypt()の仕組み】
 * 
 * 一方向ハッシュ関数：
 * - 暗号化はできる
 * - 復号化はできない（元に戻せない）
 * 
 * ログイン時の照合：
 * 
 * ユーザーが入力したパスワード「password123」
 * ↓
 * bcrypt()で暗号化
 * ↓
 * データベースの暗号化パスワードと比較
 * ↓
 * 一致すればログイン成功
 * 
 * 【Laravelの便利機能】
 * 
 * Fortifyを使えば、bcrypt()は自動で実行される。
 * 
 * でもcreate()で直接ユーザーを作る場合は、
 * 自分でbcrypt()を書く必要がある。
 * 
 * 【まとめ】
 * - bcrypt() = パスワード暗号化の関数
 * - 平文保存は危険
 * - Laravelではほぼ必須
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【Q8. GodeVenでの応用アイデア】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 質問：
 * GodeVenで、今日学んだcreate()、update()、delete()は
 * どのように使えますか？
 * 
 * 回答：
 * 
 * GodeVenでの具体的な使い道をイメージしてみましょう。
 * 
 * 【シナリオ1：家計簿アプリ】
 * 
 * ⓵ 支出記録を作成（create）
 * 
 * Expense::create([
 *     'user_id' => $userId,
 *     'amount' => 500,
 *     'category' => '食費',
 *     'description' => 'コンビニで昼食',
 *     'date' => today()
 * ]);
 * 
 * ⓶ 支出記録を修正（update）
 * 
 * $expense = Expense::find($id);
 * $expense->update([
 *     'amount' => 600,  // 金額を修正
 *     'description' => 'コンビニで昼食とコーヒー'
 * ]);
 * 
 * ⓷ 支出記録を削除（delete）
 * 
 * $expense = Expense::find($id);
 * $expense->delete();
 * 
 * 【シナリオ2：at Bridge（助け合いアプリ）】
 * 
 * ⓵ 依頼を作成（create）
 * 
 * Request::create([
 *     'user_id' => $userId,
 *     'title' => '引越しの手伝いをお願いします',
 *     'description' => '...',
 *     'location' => '大阪市',
 *     'date' => '2025-12-25',
 *     'status' => 'open'
 * ]);
 * 
 * ⓶ 依頼のステータスを更新（update）
 * 
 * $request = Request::find($id);
 * $request->update(['status' => 'matched']);
 * 
 * ⓷ 依頼を取り消し（delete）
 * 
 * $request = Request::find($id);
 * $request->delete();  // または論理削除
 * 
 * 【シナリオ3：ユーザー管理】
 * 
 * ⓵ 新規ユーザー登録（create）
 * 
 * User::create([
 *     'name' => '山田太郎',
 *     'email' => 'yamada@example.com',
 *     'password' => bcrypt('password123')
 * ]);
 * 
 * ⓶ プロフィール更新（update）
 * 
 * $user = User::find($userId);
 * $user->update([
 *     'name' => '山田花子',  // 結婚して名前変更
 *     'phone' => '090-1234-5678'
 * ]);
 * 
 * ⓷ アカウント削除（delete）
 * 
 * $user = User::find($userId);
 * $user->delete();  // SoftDeletesで論理削除推奨
 * 
 * 【まとめ】
 * - create() = 新規登録・投稿・記録作成
 * - update() = プロフィール編集・ステータス変更・金額修正
 * - delete() = 取り消し・退会・記録削除
 * 
 * GodeVenのどの機能でも、CUDは必須です！
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【Q9. save()について】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 質問：
 * save()はいつ使いますか？
 * 
 * 回答：
 * 
 * save()は以下の2つの場面で使います。
 * 
 * 【場面1：new した後】
 * 
 * $user = new User();
 * $user->name = '太郎';
 * $user->email = 'taro@example.com';
 * $user->password = bcrypt('pass');
 * $user->save();  // ← ここで保存
 * 
 * これは create() の代わりになります。
 * 
 * 【場面2：プロパティを変更した後】
 * 
 * $user = User::find(1);
 * $user->name = '新しい名前';
 * $user->save();  // ← ここで保存
 * 
 * これは update() の代わりになります。
 * 
 * 【create()・update() と save() の違い】
 * 
 * create()・update()：
 * - 配列で一気に渡す
 * - 簡潔
 * 
 * new + save()・プロパティ変更 + save()：
 * - 1つずつ設定
 * - 途中で条件分岐できる
 * 
 * 【途中で条件分岐の例】
 * 
 * $user = new User();
 * $user->name = '太郎';
 * $user->email = 'taro@example.com';
 * 
 * // 管理者の場合だけ特別な設定
 * if ($isAdmin) {
 *     $user->role = 'admin';
 * }
 * 
 * $user->save();
 * 
 * 【まとめ】
 * - save() = データを保存する命令
 * - new した後 or プロパティ変更した後に使う
 * - create()・update() より柔軟
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【おわりに】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Step5-03（Eloquent基本操作 - 作成・更新・削除）の学習、
 * お疲れさまでした！
 * 
 * 次のStepでは、Expenseモデルを作成し、
 * UserとExpenseのリレーション（関係性）を学びます。
 * 
 * 今日学んだcreate()、update()、delete()は、
 * 次のStepでも使います。
 * 
 * しっかり復習しておきましょう！
 */
