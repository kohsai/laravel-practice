<?php

/**
 * 📘 Day5 教材（Step5-05：リレーション - UserとExpenseの関連付け）【統合版】
 * 
 * この教材では「2つのテーブルを関連付ける方法」を学びます
 * 
 * 【統合版について】
 * この教材は、基本教材に加えて、学習中に出た質問と回答を統合したものです。
 * 
 * 構成：
 * - 第1部：基本教材（リレーションの概念と使い方）
 * - 第2部：追加Q&A（学習中に出た質問と回答）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【第1部：基本教材】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🧠 【今日学ぶこと】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【リレーションって何？】
 * リレーション（relation） = 「関係」という意味
 * データベースの中で「2つのテーブルをつなぐ」仕組みです。
 * 
 * 【なぜリレーションが必要？】
 * 今回の例で考えてみましょう：
 * - usersテーブル = 人の情報（名前、メール、パスワード）
 * - expensesテーブル = 支出の情報（金額、カテゴリー、日付）
 * 
 * 「誰の支出なのか？」を記録するには、2つのテーブルをつなぐ必要があります。
 * 
 * 【たとえ話】
 * - usersテーブル = 学校のクラス名簿（生徒の基本情報）
 * - expensesテーブル = テストの答案用紙（点数や日付）
 * - リレーション = 「この答案は誰のもの？」をつなぐ仕組み
 * 
 * 答案用紙に「出席番号」を書いておけば、
 * 「この答案は出席番号5番の山田さんのものだ」とわかります。
 * データベースでも同じように「user_id」で関連付けます。
 * 
 * 【今日学ぶ2つのリレーション】
 * 1. hasMany（ハズメニー） = 「1人は複数の〇〇を持つ」
 * 2. belongsTo（ビロングストゥー） = 「1つの〇〇は1人に属する」
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📊 【リレーションの全体像】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【1対多の関係（one-to-many）】
 * 
 * User（1人） ──┬── Expense（支出1）
 *                ├── Expense（支出2）
 *                ├── Expense（支出3）
 *                └── Expense（支出4）
 * 
 * 例：山田さん（User）は4つの支出記録（Expense）を持っている
 * 
 * 【2つの視点】
 * 
 * 視点1：Userから見る（hasMany）
 * 「1人のユーザーは、複数の支出を持っている」
 * → User::find(1)->expenses; // この人の全支出を取得
 * 
 * 視点2：Expenseから見る（belongsTo）
 * 「1つの支出は、1人のユーザーに属している」
 * → Expense::find(1)->user; // この支出は誰のもの？
 * 
 * 【つなぐための仕組み】
 * expensesテーブルには「user_id」というカラムがあります。
 * これが「この支出は誰のもの？」を記録する出席番号の役割です。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【1. hasMany - 「1人は複数の支出を持つ」】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * hasMany（ハズメニー） = 「has（持っている） + many（たくさん）」
 * 
 * 【意味】
 * 1人のユーザーは、複数の支出記録を持っている
 * 
 * 【たとえ話】
 * 山田さん（User）は、今月5回買い物をしました。
 * その5回分のレシート（Expense）を全部持っています。
 * 
 * 「山田さんのレシートを全部見せて」→ これがhasManyです。
 * 
 * 【定義する場所】
 * Userモデル（app/Models/User.php）
 * 
 * 【定義方法】
 * 
 * public function expenses()
 * {
 *     return $this->hasMany(Expense::class);
 * }
 * 
 * 【この定義の意味】
 * - public function = 公開されたメソッド（機能）
 * - expenses() = 「支出たち」という名前の機能
 * - $this = 「この人（今見ているUser）」
 * - hasMany = 「複数持っている」
 * - Expense::class = 「Expenseモデルと関連付ける」
 * 
 * つまり：
 * 「この人（User）は、複数のExpenseを持っています」という定義
 */

/**
 * 【hasManyの使い方】
 * 
 * 定義したら、こんな風に使えます：
 */

// 以下のコードをコピーしてtinkerで実行してください：
$user = User::find(1);

/**
 * → ID番号1のユーザー（山田さん）を取得
 */

// 以下のコードをコピーしてtinkerで実行してください：
$user->expenses;

/**
 * → この人が持っている全ての支出が表示されます
 * 
 * 【返ってくるもの】
 * Collection（コレクション） = 複数の支出が入った箱
 * 
 * 例：
 * [
 *   Expense { id: 1, category: '食費', amount: 1500, ... },
 *   Expense { id: 2, category: '交通費', amount: 500, ... },
 *   Expense { id: 3, category: '娯楽費', amount: 2000, ... }
 * ]
 */

/**
 * 【重要なポイント】
 * 
 * メソッド名は複数形（expenses）にします：
 * ✅ 正しい：public function expenses()
 * ❌ 間違い：public function expense()
 * 
 * なぜ？
 * 1人のユーザーは「複数の支出」を持つからです。
 * レシートは1枚じゃなくて、何枚もあるイメージです。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * ✅ 【2. belongsTo - 「1つの支出は1人に属する」】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * belongsTo（ビロングストゥー） = 「belongs to（〜に属する）」
 * 
 * 【意味】
 * 1つの支出記録は、1人のユーザーに属している
 * 
 * 【たとえ話】
 * レシート（Expense）1枚を見たとき、
 * 「このレシートは誰のもの？」→「山田さん（User）のものです」
 * 
 * レシートの持ち主を調べる → これがbelongsToです。
 * 
 * 【定義する場所】
 * Expenseモデル（app/Models/Expense.php）
 * 
 * 【定義方法】
 * 
 * public function user()
 * {
 *     return $this->belongsTo(User::class);
 * }
 * 
 * 【この定義の意味】
 * - public function = 公開されたメソッド（機能）
 * - user() = 「持ち主」という名前の機能
 * - $this = 「この支出（今見ているExpense）」
 * - belongsTo = 「〜に属している」
 * - User::class = 「Userモデルと関連付ける」
 * 
 * つまり：
 * 「この支出（Expense）は、1人のUserに属しています」という定義
 */

/**
 * 【belongsToの使い方】
 * 
 * 定義したら、こんな風に使えます：
 */

// 以下のコードをコピーしてtinkerで実行してください：
$expense = Expense::find(1);

/**
 * → ID番号1の支出（例：1500円の食費）を取得
 */

// 以下のコードをコピーしてtinkerで実行してください：
$expense->user;

/**
 * → この支出の持ち主（User）が表示されます
 * 
 * 【返ってくるもの】
 * User { id: 1, name: '山田太郎', email: 'yamada@example.com', ... }
 * 
 * つまり：
 * 「この1500円の支出は山田太郎さんのものです」とわかります
 */

/**
 * 【重要なポイント】
 * 
 * メソッド名は単数形（user）にします：
 * ✅ 正しい：public function user()
 * ❌ 間違い：public function users()
 * 
 * なぜ？
 * 1つの支出は「1人のユーザー」に属するからです。
 * レシート1枚の持ち主は1人だけ、というイメージです。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🔗 【hasManyとbelongsToの対応関係】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * この2つは必ず「セット」で定義します。
 * 
 * 【UserモデルにhasManyを定義】
 * public function expenses()  // 複数形
 * {
 *     return $this->hasMany(Expense::class);
 * }
 * 
 * 【ExpenseモデルにbelongsToを定義】
 * public function user()  // 単数形
 * {
 *     return $this->belongsTo(User::class);
 * }
 * 
 * 【対応表】
 * 
 * | 視点 | モデル | メソッド名 | リレーション | 戻り値 |
 * |------|--------|-----------|--------------|--------|
 * | 親 | User | expenses() | hasMany | Collection（複数） |
 * | 子 | Expense | user() | belongsTo | User（1人） |
 * 
 * 【覚え方】
 * - 親（User）= 複数の子を持つ → hasMany → 複数形（expenses）
 * - 子（Expense）= 1人の親に属する → belongsTo → 単数形（user）
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 🔍 【裏側の仕組み：外部キー（user_id）】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【リレーションはどうやって動いている？】
 * 
 * expensesテーブルには「user_id」というカラムがあります。
 * これが「この支出は誰のもの？」を記録する仕組みです。
 * 
 * 【expensesテーブルの中身（例）】
 * 
 * | id | user_id | category | amount | description |
 * |----|---------|----------|--------|-------------|
 * | 1  | 1       | 食費     | 1500   | ランチ      |
 * | 2  | 1       | 交通費   | 500    | 電車代      |
 * | 3  | 2       | 食費     | 2000   | ディナー    |
 * | 4  | 1       | 娯楽費   | 3000   | 映画        |
 * 
 * 【user_idの役割】
 * - user_id = 1 → 「ユーザーID番号1の人の支出」
 * - user_id = 2 → 「ユーザーID番号2の人の支出」
 * 
 * 【hasManyの動作】
 * User::find(1)->expenses;
 * 
 * 裏側でこんなSQL（エスキューエル）が実行されます：
 * SELECT * FROM expenses WHERE user_id = 1;
 * 
 * つまり：
 * 「expensesテーブルから、user_idが1のものを全部持ってきて」
 * 
 * 【belongsToの動作】
 * Expense::find(1)->user;
 * 
 * 裏側でこんなSQLが実行されます：
 * SELECT * FROM users WHERE id = 1;
 * 
 * つまり：
 * 「この支出のuser_idを見て（1だった）、usersテーブルからID番号1の人を持ってきて」
 * 
 * 【重要】
 * これらのSQLは、Eloquentが自動的に書いてくれます。
 * 私たちはhasManyとbelongsToを定義するだけでOKです！
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📝 【まとめ】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * 【リレーション = 2つのテーブルをつなぐ仕組み】
 * 
 * 1. hasMany（ハズメニー）
 *    - 意味：1人は複数の〇〇を持つ
 *    - 定義場所：親モデル（User）
 *    - メソッド名：複数形（expenses）
 *    - 戻り値：Collection（複数）
 * 
 * 2. belongsTo（ビロングストゥー）
 *    - 意味：1つの〇〇は1人に属する
 *    - 定義場所：子モデル（Expense）
 *    - メソッド名：単数形（user）
 *    - 戻り値：User（1人）
 * 
 * 3. 外部キー
 *    - expensesテーブルの「user_id」がつなぐ役割
 *    - Eloquentが自動的にSQLを実行してくれる
 * 
 * 【次のStepで学ぶこと】
 * 実際にUserモデルとExpenseモデルにリレーションを定義して、
 * tinkerで動作確認してみます。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 💡 【よくある質問（Q&A）】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

/**
 * Q1. hasManyとbelongsToは、必ず両方定義しないとダメですか？
 * 
 * A1. 技術的には片方だけでも動きますが、両方定義するのが推奨です。
 * 
 *     片方だけの場合：
 *     - UserにhasManyだけ定義 → User::find(1)->expenses は使える
 *     - でもExpense::find(1)->user は使えない
 * 
 *     両方定義すれば：
 *     - 親から子を見る：User::find(1)->expenses
 *     - 子から親を見る：Expense::find(1)->user
 *     どちらも使えて便利です。
 */

/**
 * Q2. メソッド名は必ず「expenses」「user」じゃないとダメですか？
 * 
 * A2. いいえ、自由に決められます。ただし慣習があります。
 * 
 *     【慣習】
 *     - hasMany → 複数形（expenses、posts、comments等）
 *     - belongsTo → 単数形（user、post、category等）
 *     - 関連するモデル名を使う
 * 
 *     【例】
 *     public function myExpenses() でもOKですが、
 *     シンプルに expenses() の方がわかりやすいです。
 */

/**
 * Q3. user_idというカラム名は決まっているんですか？
 * 
 * A3. Eloquentの「規約（決まり）」です。
 * 
 *     【規約】
 *     belongsTo(User::class) と書くと、
 *     Eloquentは自動的に「user_id」というカラムを探します。
 * 
 *     【別の名前を使いたい場合】
 *     第2引数で指定できます：
 *     return $this->belongsTo(User::class, 'owner_id');
 * 
 *     でも、規約に従った方がシンプルでわかりやすいです。
 */

/**
 * Q4. 1人のユーザーが支出を1つも持っていない場合、どうなりますか？
 * 
 * A4. 空のCollection（空っぽの箱）が返ってきます。
 * 
 *     例：
 *     $user = User::find(2); // まだ支出を登録していない人
 *     $user->expenses; // Collection { }（空）
 * 
 *     【確認方法】
 *     $user->expenses->isEmpty(); // true（空っぽ）
 *     $user->expenses->count(); // 0（0個）
 */

/**
 * Q5. Expenseに紐づくUserが存在しない場合、どうなりますか？
 * 
 * A5. null（ヌル = 空っぽ）が返ってきます。
 * 
 *     例：
 *     $expense = Expense::find(1);
 *     $expense->user_id = 999; // 存在しないユーザーID
 *     $expense->save();
 *     
 *     $expense->user; // null
 * 
 *     【注意】
 *     外部キー制約を設定していれば、このような状況は防げます。
 *     （Step5-04で設定済み）
 */

/**
 * Q6. hasManyで取得したデータに、さらに条件をつけられますか？
 * 
 * A6. できます！リレーションはクエリビルダとして使えます。
 * 
 *     例：
 *     // この人の食費だけ取得
 *     $user->expenses()->where('category', '食費')->get();
 *     
 *     // この人の今月の支出だけ取得
 *     $user->expenses()
 *          ->whereMonth('spent_at', now()->month)
 *          ->get();
 * 
 *     【違い】
 *     - $user->expenses（括弧なし）→ すぐに実行
 *     - $user->expenses()（括弧あり）→ 条件を追加できる
 */

/**
 * Q7. リレーションの「1対多」って、他にどんな例がありますか？
 * 
 * A7. 実務でよく使われる例：
 * 
 *     【ブログシステム】
 *     - 1人のユーザー → 複数の記事（Post）
 *     - 1つの記事 → 複数のコメント（Comment）
 * 
 *     【ECサイト】
 *     - 1人のユーザー → 複数の注文（Order）
 *     - 1つの注文 → 複数の商品（OrderItem）
 * 
 *     【SNS】
 *     - 1人のユーザー → 複数の投稿（Post）
 *     - 1人のユーザー → 複数のフォロー（Follow）
 * 
 *     どれも同じ考え方（1対多）です。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📚 【用語集】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

/**
 * リレーション（Relation / リレーション）
 * └─ データベースの2つのテーブルをつなぐ仕組み
 * 
 * hasMany（ハズメニー）
 * └─ 「1つは複数を持つ」というリレーション
 * └─ 親モデルに定義する
 * 
 * belongsTo（ビロングストゥー）
 * └─ 「1つは1つに属する」というリレーション
 * └─ 子モデルに定義する
 * 
 * 外部キー（Foreign Key / フォーリンキー）
 * └─ 別のテーブルのIDを記録するカラム
 * └─ 例：user_id（usersテーブルのidを記録）
 * 
 * 1対多（One-to-Many / ワントゥーメニー）
 * └─ 1つの親が複数の子を持つ関係
 * └─ 例：1人のユーザー → 複数の支出
 * 
 * Collection（コレクション）
 * └─ 複数のデータが入った箱
 * └─ hasManyで返ってくるもの
 * 
 * null（ヌル）
 * └─ 「何もない」「空っぽ」という意味
 * └─ belongsToで相手が見つからない時に返る
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 【第2部：追加Q&A（学習中に出た質問と回答）】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 質問1：「公開された」とは誰に向けて公開されたのですか？
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q1-1. public function の「公開された」とは誰に向けて？
 * 
 * A1-1. 他のコード（プログラム）に向けて公開されています。
 * 
 *       【具体例】
 *       // Userモデル内でpublic function expenses()を定義
 *       // ↓
 *       // 他のコード（コントローラーやtinker）から使える
 *       $user = User::find(1);
 *       $user->expenses; // ← ここで使える！
 * 
 *       【もしprivateだったら？】
 *       → そのクラス（モデル）の中でしか使えません。外から呼べません。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 質問2：functionとはどういう意味ですか？
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q2-1. functionとは何ですか？
 * 
 * A2-1. function（ファンクション） = 「機能」「関数」という意味
 * 
 *       プログラムの世界では：
 *       - function = 「何かをする処理のかたまり」
 *       - メソッド = クラスの中にあるfunction
 * 
 *       つまり：
 *       public function expenses()
 *       = 「外から使える、expensesという名前の機能」
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 質問3：$thisについて
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q3-1. $this = 「今見ているこの人」とは？
 * 
 * A3-1. 「データベースで選択している人」という理解で完璧です。
 * 
 *       【具体例】
 *       $user = User::find(1); // 山田さん（ID=1）を取得
 *       $user->expenses; // 山田さんの支出を取得
 * 
 *       // このとき、Userモデルの中では：
 *       // $this = 山田さん（今選択されているUser）
 * 
 * Q3-2. tinkerで実行してもデータが返ってこない？
 * 
 * A3-2. はい、おっしゃる通りです。
 * 
 *       現時点では：
 *       - ✅ User（id=1）は存在する（Step5-04で作成済み）
 *       - ✅ Expense（id=1）も存在する（Step5-04で作成済み）
 *       - ❌ でもまだリレーションを定義していない
 * 
 *       なので：
 *       $user = User::find(1);
 *       $user->expenses; // ← エラーが出ます
 * 
 *       エラー内容：
 *       「Call to undefined method ... expenses()」
 *       = 「expensesというメソッドは定義されていません」
 * 
 *       次のステップで定義すれば、データが返ってきます。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 質問4：= と -> の使い分けは？
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q4-1. $user = User::find(1); ここで=を使うのはなぜ？
 * Q4-2. $user->expenses; ここで->を使うのはなぜ？
 * Q4-3. 両方の使い分けは？
 * 
 * A4. 素晴らしい質問です！これは重要な違いです。
 * 
 *     【=（イコール）= 「代入」】
 *     $user = User::find(1);
 * 
 *     意味：
 *     「User::find(1)の結果を、$userという箱に入れる」
 * 
 *     たとえ話：
 *     バケツ（$user）に水（User::find(1)の結果）を入れる
 * 
 *     【->（アロー）= 「取り出す」「実行する」】
 *     $user->expenses;
 * 
 *     意味：
 *     「$userという箱の中身から、expensesを取り出す」
 * 
 *     たとえ話：
 *     バケツの中の水から、特定の情報（expenses）を取り出す
 * 
 *     【使い分けの例】
 *     // = は「入れる」
 *     $user = User::find(1); // find(1)の結果を$userに入れる
 *     $name = $user->name;   // $user->nameの結果を$nameに入れる
 * 
 *     // -> は「取り出す・実行する」
 *     $user->expenses;       // $userからexpensesを取り出す
 *     $user->save();         // $userのsave()を実行する
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 質問5：「子」の考え方について
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q5-1. user（親）とリレーションする「子」は、expenses以外にもありますよね？
 * Q5-2. その場合の対応表はどうなりますか？
 * 
 * A5. 素晴らしい質問です。これは理解の核心です。
 * 
 *     【ポイント】
 *     「親」と「子」は相対的な関係です。絶対的なものではありません。
 * 
 *     【例1：Userとの関係】
 *     User（親）
 *      ├─ expenses（子）  // 1人のユーザーは複数の支出を持つ
 *      ├─ posts（子）     // 1人のユーザーは複数の投稿を持つ
 *      └─ comments（子）  // 1人のユーザーは複数のコメントを持つ
 * 
 *     【例2：Postとの関係】
 *     Post（親）
 *      └─ comments（子）  // 1つの投稿は複数のコメントを持つ
 * 
 *     Comment（子）
 *      ├─ Post（親）      // 1つのコメントは1つの投稿に属する
 *      └─ User（親）      // 1つのコメントは1人のユーザーに属する
 * 
 *     【つまり】
 *     - 同じCommentでも、Postから見れば「子」
 *     - でもUserから見ても「子」
 *     - Commentは2つの親を持つことができる
 * 
 *     【対応表：パターン1（User と Expense）】
 *     | 視点 | モデル | メソッド名 | リレーション | 戻り値 |
 *     |------|--------|-----------|--------------|--------|
 *     | 親 | User | expenses() | hasMany | Collection（複数のExpense） |
 *     | 子 | Expense | user() | belongsTo | User（1人） |
 * 
 *     【対応表：パターン2（User と Post）】
 *     | 視点 | モデル | メソッド名 | リレーション | 戻り値 |
 *     |------|--------|-----------|--------------|--------|
 *     | 親 | User | posts() | hasMany | Collection（複数のPost） |
 *     | 子 | Post | user() | belongsTo | User（1人） |
 * 
 *     【対応表：パターン3（Post と Comment）】
 *     | 視点 | モデル | メソッド名 | リレーション | 戻り値 |
 *     |------|--------|-----------|--------------|--------|
 *     | 親 | Post | comments() | hasMany | Collection（複数のComment） |
 *     | 子 | Comment | post() | belongsTo | Post（1つ） |
 * 
 *     【覚え方】
 *     「1対多」の関係を探す：
 *     - 1人のユーザーは複数の〇〇を持つ → User（親）と 〇〇（子）
 *     - 1つの〇〇は1人のユーザーに属する → 〇〇（子）と User（親）
 * 
 *     判断基準：
 *     - 「複数持つ」側 = 親 = hasMany
 *     - 「1つに属する」側 = 子 = belongsTo
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 質問6：外部キーについて
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q6-1. expensesテーブルで、idの番号によって個別ユーザーを判別する？
 * 
 * A6-1. 完璧な理解です！
 * 
 *       【expensesテーブル】
 *       | id | user_id | category | amount |
 *       |----|---------|----------|--------|
 *       | 1  | 1       | 食費     | 1500   |
 *       | 2  | 1       | 交通費   | 500    |
 *       | 3  | 2       | 食費     | 2000   |
 * 
 *       【流れ】
 *       1. $user = User::find(1); 
 *          → ID=1のユーザー（山田さん）を取得
 * 
 *       2. $user->expenses; 
 *          → 「このユーザー（山田さん）の支出を全部ちょうだい」
 * 
 *       3. Eloquentが裏側でSQL実行：
 *          SELECT * FROM expenses WHERE user_id = 1;
 * 
 *       4. user_id=1のレコード（id=1とid=2）が返ってくる
 * 
 *       【つまり】
 *       - usersテーブルのid = 個別ユーザーを判別する番号
 *       - expensesテーブルのuser_id = 「この支出は誰のもの？」を記録する番号
 *       - user_id = 1 → 「ID=1の人（山田さん）の支出」
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 質問7：クエリビルダとは？
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q7-1. クエリビルダとは何ですか？
 * 
 * A7-1. クエリビルダ（Query Builder） = 「SQL文を組み立てる道具」
 * 
 *       【普通の使い方】
 *       $user->expenses; // 全部の支出を取得
 * 
 *       【クエリビルダとして使う】
 *       // 条件を追加できる
 *       $user->expenses()->where('category', '食費')->get();
 * 
 *       【違い】
 *       | 書き方 | 意味 | 実行タイミング |
 *       |--------|------|----------------|
 *       | $user->expenses | すぐ実行（全部取得） | その場で実行 |
 *       | $user->expenses() | まだ実行しない（条件を追加できる） | get()で実行 |
 * 
 *       【具体例】
 *       // 例1：この人の食費だけ
 *       $user->expenses()
 *            ->where('category', '食費')
 *            ->get();
 * 
 *       // 例2：この人の今月の支出だけ
 *       $user->expenses()
 *            ->whereMonth('spent_at', now()->month)
 *            ->get();
 * 
 *       // 例3：この人の1000円以上の支出だけ
 *       $user->expenses()
 *            ->where('amount', '>=', 1000)
 *            ->get();
 * 
 *       【たとえ話】
 *       - $user->expenses = 「山田さんのレシート全部ちょうだい」
 *       - $user->expenses()->where(...)->get() = 「山田さんのレシートで、食費だけちょうだい」
 * 
 *       つまり：
 *       クエリビルダ = 条件をつけてデータを絞り込む道具
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 質問8：get()を付け忘れるとどうなる？
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * Q8-1. 条件をつけた後、get()を付け忘れるとどうなりますか？
 * 
 * A8-1. シンプルにまとめます：
 * 
 *       【覚えること】
 *       条件をつけたら、最後に必ず get(); をつける
 * 
 *       ✅ 正しい
 *       $user->expenses()->where('category', '食費')->get();
 * 
 *       ❌ 間違い（get()を忘れている）
 *       $user->expenses()->where('category', '食費');
 * 
 *       【何が起こるか？】
 *       get()を忘れると、データではなく「道具（Builder）」が返ってきます。
 *       そのまま使うとエラーが出たり、期待と違う動作になります。
 * 
 *       【重要】
 *       細かい理屈は、実際にコードを書いていく中で自然に理解できます。
 *       まずは「条件つけたらget()」だけ覚えておけば大丈夫です。
 */

/**
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 📝 【統合版 まとめ】
 * ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 * 
 * この統合版では、以下の内容を学びました：
 * 
 * 【基本教材で学んだこと】
 * 1. リレーションの概念（2つのテーブルをつなぐ）
 * 2. hasMany（1人は複数の〇〇を持つ）
 * 3. belongsTo（1つの〇〇は1人に属する）
 * 4. 外部キー（user_id）の仕組み
 * 
 * 【追加Q&Aで学んだこと】
 * 1. public functionの意味（他のコードから使える機能）
 * 2. functionの意味（処理のかたまり）
 * 3. $thisの意味（今選択されているデータ）
 * 4. =と->の使い分け（代入 vs 取り出す・実行する）
 * 5. 「子」の考え方（相対的な関係、1対多で判断）
 * 6. 外部キーの仕組み（user_idで判別）
 * 7. クエリビルダ（条件をつけてデータを絞り込む道具）
 * 8. get()の重要性（条件つけたら必ずget()）
 * 
 * 【次のステップ】
 * 実際にUserモデルとExpenseモデルにリレーションを定義して、
 * tinkerで動作確認してみます。
 */
